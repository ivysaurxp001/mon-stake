Embed MetaMask Smart Accounts using the Delegation Toolkit
The MetaMask Delegation Toolkit is a Viem-based collection of tools for embedding MetaMask Smart Accounts into dapps. Smart accounts support programmable account behavior and advanced features like delegated permissions, multi-signature approvals, and gas abstraction.

Delegation is a core feature of MetaMask Smart Accounts, enabling secure, rule-based permission sharing. Delegation is powered by the toolkit's Delegation Framework, which defines how permissions are created, shared, and enforced.

Why use the toolkit?
The toolkit enables developers to create frictionless new experiences based on programmable account behavior and granular permission sharing. The toolkit offers a suite of contracts, libraries, and services designed for maximum composability, allowing developers to build and extend their dapps with ease.

The toolkit enables:

Instant user onboarding. Instantly onboard users with embedded MetaMask Smart Accounts — no browser extension, mobile app, or seed phrase required.

New web3 experiences. Unlock new experiences such as peer-to-peer social coordination using incentive trees, or recurring subscription payments that don't require users to connect to the dapp.

Uninterrupted user experiences. Keep users immersed in the dapp by embedding the wallet experience and reassigning gas costs to where they make sense.

Where do I start?
Check out the following guides to get started with the MetaMask Delegation Toolkit:

Install and set up
Install and set up the MetaMask Delegation Toolkit.

MetaMask Smart Accounts quickstart
Create a MetaMask smart account and send a user operation.

EIP-7702 quickstart
Upgrade an externally owned account to a smart account.

Use the CLI
Use the Delegation Toolkit CLI to bootstrap a project.

Partner integrations
The MetaMask Delegation Toolkit is integrated with multiple ecosystem partners. Check out the following documentation from these partners:

Scaffold-ETH 2
Install the MetaMask Delegation Toolkit extension for Scaffold-ETH 2.

Viem
Use MetaMask Smart Accounts with Viem.

Arbitrum
Use MetaMask Smart Accounts with Arbitrum.
1
permissionless.js
Use MetaMask Smart Accounts with permissionless.js.

Monad
Use MetaMask Smart Accounts with Monad Testnet.
Install and set up the Delegation Toolkit
This page provides instructions to install and set up the MetaMask Delegation Toolkit, enabling you to integrate MetaMask Smart Accounts into your dapp.

Prerequisites
Install Node.js v18 or later.
Install Yarn, npm, or another package manager.
If you plan to use any smart contracts (for example, to create a custom caveat enforcer), install Foundry.
Steps
1. Install the toolkit
Install the MetaMask Delegation Toolkit:

npm
Yarn
pnpm
Bun
npm install @metamask/delegation-toolkit
2. (Optional) Install the contracts
If you plan to extend the Delegation Framework smart contracts (for example, to create a custom caveat enforcer), install the contract package using Foundry's command-line tool, Forge:

forge install metamask/delegation-framework@v1.3.0
Add @metamask/delegation-framework/=lib/metamask/delegation-framework/ in your remappings.txt file.

3. Get started
You're now ready to start using the Delegation Toolkit. See the MetaMask Smart Accounts quickstart to walk through a simple example.
MetaMask Smart Accounts quickstart
You can get started quickly with MetaMask Smart Accounts by creating your first smart account and sending a user operation.

Prerequisites
Install Node.js v18 or later.
Install Yarn, npm, or another package manager.
Steps
1. Install the toolkit
Install the MetaMask Delegation Toolkit:
1
npm
Yarn
pnpm
Bun
npm install @metamask/delegation-toolkit
2. Set up a Public Client
Set up a Viem Public Client using Viem's createPublicClient function. This client will let the smart account query the signer's account state and interact with blockchain network.

import { createPublicClient, http } from "viem";
import { sepolia as chain } from "viem/chains";

const publicClient = createPublicClient({
  chain,
  transport: http(),
});
3. Set up a Bundler Client
Set up a Viem Bundler Client using Viem's createBundlerClient function. This lets you use the bundler service to estimate gas for user operations and submit transactions to the network.

import { createBundlerClient } from "viem/account-abstraction";

const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://your-bundler-rpc.com"),
});
4. Create a MetaMask smart account
Create a MetaMask smart account to send the first user operation.

This example configures a Hybrid smart account, which is a flexible smart account implementation that supports both an externally owned account (EOA) owner and any number of passkey (WebAuthn) signers:

import { Implementation, toMetaMaskSmartAccount } from "@metamask/delegation-toolkit";
import { privateKeyToAccount } from "viem/accounts";

const account = privateKeyToAccount("0x...");

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: "0x",
  signer: { account },
});
5. Send a user operation
Send a user operation using Viem's sendUserOperation method.

See Send a user operation to learn how to estimate fee per gas, and wait for the transaction receipt.

The smart account will remain counterfactual until the first user operation. If the smart account is not deployed, it will be automatically deployed upon the sending first user operation.

import { parseEther } from "viem";

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1"),
    },
  ],
  maxFeePerGas,
  maxPriorityFeePerGas,
});
Next steps
To grant specific permissions to other accounts from your smart account, create a delegation.
This quickstart example uses a Hybrid smart account. You can also configure other smart account types.
To upgrade an EOA to a smart account, see the EIP-7702 quickstart.
To quickly bootstrap a MetaMask Smart Accounts project, use the CLI.
EIP-7702 quickstart
This quickstart demonstrates how to upgrade your externally owned account (EOA) to support MetaMask Smart Accounts functionality using an EIP-7702 transaction. This enables your EOA to leverage the benefits of account abstraction, such as batch transactions, gas sponsorship, and delegation capabilities.

Prerequisites
Install Node.js v18 or later.
Install Yarn, npm, or another package manager.
Install Viem.
Steps
1. Install the toolkit
Install the MetaMask Delegation Toolkit:

npm
Yarn
pnpm
Bun
npm install @metamask/delegation-toolkit
2. Set up a Public Client
Set up a Viem Public Client using Viem's createPublicClient function. This client will let the EOA query the account state and interact with blockchain network.

import { createPublicClient, http } from "viem";
import { sepolia as chain } from "viem/chains";
 
const publicClient = createPublicClient({
  chain,
  transport: http(),
});
3. Set up a Bundler Client
Set up a Viem Bundler Client using Viem's createBundlerClient function. This lets you use the bundler service to estimate gas for user operations and submit transactions to the network.

import { createBundlerClient } from "viem/account-abstraction";

const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://your-bundler-rpc.com"),
});
4. Set up a Wallet Client
Set up Viem Wallet Client using Viem's createWalletClient function. This lets you sign and submit EIP-7702 authorization.

import { createWalletClient, http } from "viem";
import { sepolia as chain } from "viem/chains";
import { privateKeyToAccount } from "viem/accounts";
 
export const account = privateKeyToAccount("0x...");
 
export const walletClient = createWalletClient({
  account,
  chain,
  transport: http(),
});
5. Authorize a 7702 delegation
Create an authorization to map the contract code to an EOA, and sign it using Viem's signAuthorization action. The signAuthorization action does not support JSON-RPC accounts.

This example uses EIP7702StatelessDeleGator as the EIP-7702 delegator contract. It follows a stateless design, as it does not store signer data in the contract's state. This approach provides a lightweight and secure way to upgrade an EOA to a smart account.

import {
  Implementation,
  toMetaMaskSmartAccount,
  getDeleGatorEnvironment,
} from "@metamask/delegation-toolkit";
import { privateKeyToAccount } from "viem/accounts";

const environment = getDeleGatorEnvironment(sepolia.id);
const contractAddress = environment.implementations.EIP7702StatelessDeleGatorImpl;

const authorization = await walletClient.signAuthorization({
  account, 
  contractAddress,
  executor: "self", 
});
6. Submit the authorization
Once you have signed an authorization, you can send an EIP-7702 transaction to set the EOA code. Since the authorization cannot be sent by itself, you can include it alongside a dummy transaction.

import { zeroAddress } from "viem";

const hash = await walletClient.sendTransaction({ 
  authorizationList: [authorization], 
  data: "0x", 
  to: zeroAddress, 
});
7. Create a MetaMask smart account
Create a smart account instance for the EOA and start leveraging the benefits of account abstraction.

import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const addresses = await walletClient.getAddresses();
const address = addresses[0];

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Stateless7702,
  address, 
  signer: { walletClient },
});
8. Send a user operation
Send a user operation through the upgraded EOA, using Viem's sendUserOperation method.

import { parseEther } from "viem";

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1")
    }
  ],
  maxFeePerGas,
  maxPriorityFeePerGas
});
Next steps
To grant specific permissions to other accounts from your smart account, create a delegation.
To quickly bootstrap a MetaMask Smart Accounts project, use the CLI.
You can also use MetaMask SDK to upgrade a MetaMask account to a smart account.
Use the Delegation Toolkit CLI
Use the @metamask/create-gator-app interactive CLI to bootstrap a project with the MetaMask Delegation Toolkit in under two minutes. The CLI automatically installs the required dependencies and sets up a project structure using a selected template, allowing you to focus on building your dapp.

Run the CLI
Run the following command to automatically install the @metamask/create-gator-app package:

npx @metamask/create-gator-app@latest
Upon installation, you'll be asked the following prompts:

? What is your project named? (my-gator-app)
? Pick a framework: (Use arrow keys) 
❯ nextjs
  vite-react
? Pick a template: (Use arrow keys)
❯ MetaMask Smart Accounts Starter
  MetaMask Smart Accounts & Delegation Starter
  Farcaster Mini App Delegation Starter 
  Experimental: ERC7715 Permissions starter
? Pick a package manager: (Use arrow keys)
❯ npm 
  yarn 
  pnpm 
Once you've answered the prompts with the required configuration and selected a template, the CLI will create the project using the specified name and settings. See the following section to learn more about available CLI configurations.

Options
The CLI provides the following options to display CLI details, and further customize the template configuration.

Option	Description
-v or --version	Check the current version of the @metamask/create-gator-app CLI.
-h or --help	Display the available options.
--skip-install	Skip the installation of dependencies.
--add-web3auth	Add MetaMask Embedded Wallets (previously Web3Auth) as a signer for the delegator account.
Supported templates:
- MetaMask Smart Accounts Starter
- MetaMask Smart Accounts & Delegation Starter
--add-llm-rules	Add LLM rules for your IDE. Supported in the Experimental: ERC7715 Permissions Starter template.
Examples
MetaMask Embedded Wallets configuration
To create a project that uses MetaMask Embedded Wallets as the signer for your delegator account, use the --add-web3auth option with @metamask/create-gator-app:

npx @metamask/create-gator-app --add-web3auth
You'll be prompted to provide additional Web3Auth configuration details:

? Which Web3Auth network do you want to use? (Use arrow keys)
❯ Sapphire Devnet 
  Sapphire Mainnet 
LLM rules
To create a project with LLM rules tailored to your preferred IDE, use the --add-llm-rules option with @metamask/create-gator-app:

npx @metamask/create-gator-app --add-llm-rules
You'll be prompted to select your IDE. Currently, only Cursor and Windsurf are supported.

? Which IDE's LLM rules would you like to copy? (Use arrow keys)
  Cursor 
  Windsurf 
❯ Both 
Supported templates
Template	Next.js	Vite React
MetaMask Smart Accounts Starter	✅	✅
MetaMask Smart Accounts & Delegation Starter	✅	✅
Farcaster Mini App Delegation Starter	✅	
Experimental: ERC7715 Permissions starter	✅	
Edit this page

Supported networks
The following tables display the networks supported by each version of the MetaMask Delegation Toolkit.

If you don't see the network you're looking for, you can request support by emailing hellogators@consensys.net.

Mainnet networks
Network Name	v0.11.0	v0.12.0	v0.13.0
Ethereum	✅	✅	✅
Polygon	✅	✅	✅
Binance Smart Chain	✅	✅	✅
Optimism	✅	✅	✅
Arbitrum One	✅	✅	✅
Base	✅	✅	✅
Gnosis Chain	✅	✅	✅
Unichain	❌	✅	✅
Arbitrum Nova	❌	✅	✅
Berachain	❌	✅	✅
Testnet networks
Network Name	v0.11.0	v0.12.0	v0.13.0
Ethereum Sepolia	✅	✅	✅
Base Sepolia	✅	✅	✅
MegaEth	✅	✅	✅
Gnosis Chiado	✅	✅	✅
Arbitrum Sepolia	❌	✅	✅
Unichain Sepolia	❌	✅	✅
Berachain Bepolia	❌	✅	✅
Optimism Sepolia	❌	✅	✅
Binance Smart Chain	❌	✅	✅
Polygon Amoy	❌	✅	✅
Monad	❌	✅	✅
MetaMask Smart Accounts
The MetaMask Delegation Toolkit enables you to create and manage MetaMask Smart Accounts. MetaMask Smart Accounts are ERC-4337 smart contract accounts that support programmable account behavior and advanced features such as multi-signature approvals, automated transaction batching, and custom security policies. Unlike traditional wallets, which rely on private keys for every transaction, MetaMask Smart Accounts use smart contracts to govern account logic.

MetaMask Smart Accounts are referenced in the toolkit as MetaMaskSmartAccount.

Account abstraction (ERC-4337)
Account abstraction, specified by ERC-4337, is a mechanism that enables users to manage smart contract accounts containing arbitrary verification logic. ERC-4337 enables smart contracts to be used as primary accounts in place of traditional private key-based accounts, or externally owned accounts (EOAs).

ERC-4337 introduces the following concepts:

User operation - A package of instructions signed by a user, specifying executions for the smart account to perform. User operations are collected and submitted to the network by bundlers.

Bundler - A service that collects multiple user operations, packages them into a single transaction, and submits them to the network, optimizing gas costs and transaction efficiency.

Entry point contract - A contract that validates and processes bundled user operations, ensuring they adhere to the required rules and security checks.

Paymasters - Entities that handle the payment of gas fees on behalf of users, often integrated into smart accounts to facilitate gas abstraction.

Smart account implementation types
The MetaMask Delegation Toolkit supports three types of MetaMask Smart Accounts, each offering unique features and use cases.

See Create a smart account to learn how to use these different account types.

Hybrid smart account
The Hybrid smart account is a flexible implementation that supports both an externally owned account (EOA) owner and any number of passkey (WebAuthn) signers. You can configure any of these signers, and use them to sign any data, including user operations, on behalf of the smart account.

This type is referenced in the toolkit as Implementation.Hybrid.

Multisig smart account
The Multisig smart account is an implementation that supports multiple signers with a configurable threshold, allowing for enhanced security and flexibility in account management. A valid signature requires signatures from at least the number of signers specified by the threshold.

This type is referenced in the toolkit as Implementation.Multisig.

Stateless 7702 smart account
The Stateless 7702 smart account implementation represents an externally owned account (EOA) upgraded to support smart account functionality as defined by EIP-7702. This implementation enables EOAs to perform smart account operations, including the creation and management of delegations.

This type is referenced in the toolkit as Implementation.Stateless7702.

Smart account flow
The MetaMask Smart Accounts flow is as follows:

Account setup - A user creates a smart account by deploying a smart contract, and initializing it with ownership and security settings. The user can customize the smart account in the following ways:

Account logic - They can configure custom logic for actions such as multi-signature approvals, spending limits, and automated transaction batching.

Security and recovery - They can configure advanced security features such as two-factor authentication and mechanisms for account recovery involving trusted parties.

Gas management - They can configure flexible gas payment options, including alternative tokens or third-party sponsorship.

User operation creation - For actions such as sending transactions, a user operation is created with necessary details and signed by the configured signers.

Bundlers and mempool - The signed user operation is submitted to a special mempool, where bundlers collect and package multiple user operations into a single transaction to save on gas costs.

Validation and execution - The bundled transaction goes to an entry point contract, which validates each user operation and executes them if they meet the smart contract's rules.

Delegator accounts
Delegator accounts are a type of MetaMask smart account that allows users to grant permission to other smart accounts or EOAs to perform specific executions on their behalf, under defined rules and restrictions. Learn more about delegation.
Delegation
Delegation is the ability for a MetaMask smart account to grant permission to another smart account or externally owned account (EOA) to perform specific executions on its behalf. The account that grants the permission is called the delegator account, while the account that receives the permission is called the delegate account.

The MetaMask Delegation Toolkit follows the ERC-7710 standard for smart contract delegation. In addition, users can use caveat enforcers to apply rules and restrictions to delegations. For example: Alice delegates the ability to spend her USDC to Bob, limiting the amount to 100 USDC.

Delegation lifecycle
The delegation lifecycle is as follows:

Create a delegation - The delegator account creates a delegation, applying caveats which specify conditions under which the delegation can be redeemed. The delegator signs the delegation.

Store the delegation - A dapp can store the delegation, enabling retrieval for future redemption.

Redeem the delegation - The delegate (the account being granted the permission) redeems the delegation via the Delegation Manager, which verifies that the delegated authority is valid in order to perform the execution.

See how to perform executions on a smart account's behalf to get started with the delegation lifecycle.

Delegation types
You can create the following delegation types:

Root delegation - A root delegation is when a delegator delegates their own authority away, as opposed to redelegating permissions they received from a previous delegation. In a chain of delegations, the first delegation is the root delegation. For example, Alice delegates the ability to spend her USDC to Bob, limiting the amount to 100 USDC.

Use createDelegation to create a root delegation.

Open root delegation - An open root delegation is a root delegation that doesn't specify a delegate. This means that any account can redeem the delegation. For example, Alice delegates the ability to spend 100 of her USDC to anyone.

You must create open root delegations carefully, to ensure that they are not misused. Use createOpenDelegation to create an open root delegation.

Redelegation - A delegate can redelegate permissions that have been granted to them, creating a chain of delegations across trusted parties. For example, Alice delegates the ability to spend 100 of her USDC to Bob. Bob redelegates the ability to spend 50 of Alice's 100 USDC to Carol.

Use createDelegation to create a redelegation.

Open redelegation - An open redelegation is a redelegation that doesn't specify a delegate. This means that any account can redeem the redelegation. For example, Alice delegates the ability to spend 100 of her USDC to Bob. Bob redelegates the ability to spend 50 of Alice's 100 USDC to anyone.

As with open root delegations, you must create open redelegations carefully, to ensure that they are not misused. Use createOpenDelegation to create an open redelegation.

Delegation Framework
The MetaMask Delegation Toolkit includes the Delegation Framework, which is a set of comprehensively audited smart contracts that collectively handle delegator account creation, the delegation lifecycle, and caveat enforcement. It consists of the following components:

Delegator Core - Delegator Core contains the logic for the ERC-4337 compliant delegator accounts. It defines the interface needed for the Delegation Manager to invoke executions on behalf of the accounts.

Delegator account implementations - Delegator accounts are smart accounts, and there are multiple smart account implementations, with differing signature schemes used to manage the underlying account.

Delegation Manager - The Delegation Manager validates delegations and triggers executions on behalf of the delegator, ensuring tasks are executed accurately and securely.

When you redeem a delegation using redeemDelegations, the Delegation Manager performs the following steps. It processes a single step for all redemptions before proceeding to the next one:

Validates the input data by ensuring the lengths of delegations, modes, and executions match.
Decodes and validates the delegation, checking that the caller is the delegate and that there are no empty signatures.
Verifies delegation signatures, ensuring validity using ECDSA (for EOAs) or isValidSignature (for contracts).
Validates the delegation chain's authority and ensures delegations are not disabled.
Executes the beforeHook for each caveat in the delegation, passing relevant data (terms, arguments, mode, execution calldata, and delegationHash) to the caveat enforcer.
Calls executeFromExecutor to perform the delegation's execution, either by the delegator or the caller for self-authorized executions.
Executes the afterHook for each caveat, similar to the beforeHook, passing required data to enforce post-execution conditions.
Emits RedeemedDelegation events for each delegation that was successfully redeemed.
Caveat enforcers - Caveat enforcers manage rules and restrictions for delegations, providing fine-tuned control over delegated executions.

Delegation flow
This diagram shows how a delegation is created and redeemed with the Delegation Manager. The Delegation Manager is responsible for validating the signature of the delegation and the caveat enforcers. If everything is correct, it allows a delegate to execute an action on behalf of the delegator.

Learn more about the caveat enforcer hooks in the Caveat enforcers section.

Caveat enforcer
Delegation Manager
Delegate
Delegator
Caveat enforcer
Delegation Manager
Delegate
Delegator
Hold delegation until
redemption
Expect no error
Expect no error
Expect no error
Expect no error
Expect no error
Create delegation with caveat
enforcers
Sign delegation
Send signed delegation
redeemDelegations() with delegation &
execution details
isValidSignature()
Confirm valid (or not)
beforeAllHook()
beforeHook()
executeFromExecutor() with execution details
Perform execution
afterHook()
afterAllHook()
Execution modes
When redeeming a delegation using redeemDelegations, you must pass an execution mode for each delegation chain you pass to the method. The Delegation Toolkit supports the following execution modes, based on ERC-7579:

Execution mode	Number of delegation chains passed to redeemDelegations	Processing method	Does user operation continue execution if redemption reverts?
SingleDefault	One	Sequential	No
SingleTry	One	Sequential	Yes
BatchDefault	Multiple	Interleaved	No
BatchTry	Multiple	Interleaved	Yes
Sequential processing
In Single modes, processing is sequential:

For each delegation in the chain, all caveats' before hooks are called.
The single redeemed action is executed.
For each delegation in the chain, all caveats' after hooks are called.
Interleaved processing
In Batch modes, processing is interleaved:

For each chain in the batch, and each delegation in the chain, all caveats' before hooks are called.
Each redeemed action is executed.
For each chain in the batch, and each delegation in the chain, all caveats' after hooks are called.
Batch mode allows for powerful use cases, but the Delegation Framework currently does not include any Batch compatible caveat enforcers.
Caveat enforcers
The MetaMask Delegation Toolkit provides caveat enforcers, which are smart contracts that implement rules and restrictions (caveats) on delegations. They serve as the underlying mechanism that enables conditional execution within the Delegation Framework.

A caveat enforcer acts as a gate that validates whether a delegation can be used for a particular execution. When a delegate attempts to execute an action on behalf of a delegator, each caveat enforcer specified in the delegation evaluates whether the execution meets its defined criteria.

Important
Without caveat enforcers, a delegation has infinite and unbounded authority to make any execution the original account can make. We strongly recommend using caveat enforcers.
Caveat enforcers safeguard the execution process but do not guarantee a final state post-redemption. Always consider the full impact of combined caveat enforcers.
Smart contract interface
Caveat enforcers are Solidity contracts that implement the ICaveatEnforcer interface:

// SPDX-License-Identifier: MIT AND Apache-2.0
pragma solidity 0.8.23;

import { ModeCode } from "../utils/Types.sol";

/**
 * This is an abstract contract that exposes pre and post Execution hooks during delegation redemption.
 */
interface ICaveatEnforcer {
  /**
   * Enforces conditions before any actions in a batch redemption process begin.
   */
  function beforeAllHook(
    bytes calldata _terms, // The terms to enforce set by the delegator.
    bytes calldata _args, // An optional input parameter set by the redeemer at time of invocation.
    ModeCode _mode, // The mode of execution for the executionCalldata.
    bytes calldata _executionCalldata, // The data representing the execution.
    bytes32 _delegationHash, // The hash of the delegation.
    address _delegator, // The address of the delegator.
    address _redeemer // The address that is redeeming the delegation.
)
    external;

  /**
   * Enforces conditions before the execution tied to a specific delegation in the redemption process.
   */
  function beforeHook(
    bytes calldata _terms,
    bytes calldata _args,
    ModeCode _mode,
    bytes calldata _executionCalldata,
    bytes32 _delegationHash,
    address _delegator,
    address _redeemer
  )
    external;

  /**
   * Enforces conditions after the execution tied to a specific delegation in the redemption process.
   */
  function afterHook(
    bytes calldata _terms,
    bytes calldata _args,
    ModeCode _mode,
    bytes calldata _executionCalldata,
    bytes32 _delegationHash,
    address _delegator,
    address _redeemer
  )
    external;

  /**
   * Enforces conditions after all actions in a batch redemption process have been executed.
   */
  function afterAllHook(
    bytes calldata _terms,
    bytes calldata _args,
    ModeCode _mode,
    bytes calldata _executionCalldata,
    bytes32 _delegationHash,
    address _delegator,
    address _redeemer
  )
    external;
}
The interface consists of four key hook functions that are called at different stages of the delegation redemption process:

beforeAllHook: Called before any actions in a batch redemption process begin. This can be used to verify conditions that must be true for the entire batch execution.

beforeHook: Called before the execution tied to a specific delegation. This allows for pre-execution validation of conditions specific to that delegation.

afterHook: Called after the execution tied to a specific delegation completes. This can verify post-execution state changes or effects specific to that delegation.

afterAllHook: Called after all actions in a batch redemption process have completed. This enables verification of final conditions after the entire batch has executed.

Each of these hooks receives comprehensive information about the execution context, including:

The caveat terms specified by the delegator.
Optional arguments provided by the redeemer.
The execution mode and calldata.
The delegation hash.
The delegator and redeemer addresses.
Caveat enforcer rejection
The most important safety feature of these hooks is their ability to block executions:

If any hook determines its conditions aren't met, it will revert (throw an exception).
When a reversion occurs, the entire delegation redemption process is canceled.
This prevents partial or invalid executions from occurring.
No state changes from the attempted execution will be committed to the blockchain.
This "all-or-nothing" approach ensures that delegations only execute exactly as intended by their caveats.

Caveat builder
While caveat enforcers operate at the smart contract level, most developers interact with them through the CaveatBuilder interface in the MetaMask Delegation Toolkit.

The CaveatBuilder provides a developer-friendly TypeScript API that:

Abstracts away the complexity of correctly formatting and encoding caveat terms.
Provides type-checking and validation for caveat parameters.
Handles the creation of the caveats array needed when creating a delegation.
Each caveat type in the CaveatBuilder corresponds to a specific caveat enforcer contract. For example, when you use:

caveatBuilder.addCaveat("allowedTargets", ["0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92"]);
The builder is creating a caveat that references the AllowedTargetsEnforcer contract address and properly encodes the provided addresses as terms for that enforcer.

Caveat enforcer best practices
When designing delegations with caveats, consider these best practices:

Combine caveat enforcers appropriately - Use multiple caveat enforcers to create comprehensive restrictions.

Consider caveat enforcer order - When using caveat enforcers that modify external contract states, the order matters. For example, using NativeTokenPaymentEnforcer before NativeBalanceChangeEnforcer might cause validation failures.

Be careful with unbounded delegations - Always include appropriate caveat enforcers to limit what a delegate can do.

Available caveat enforcers
The Delegation Toolkit provides out-of-the-box caveat enforcers for common restriction patterns, including:

Limiting target addresses and methods.
Setting time or block number constraints.
Restricting token transfers and approvals.
Limiting execution frequency.
For other restriction patterns, you can also create custom caveat enforcers by implementing the ICaveatEnforcer interface.

Attenuating authority with redelegations
When creating chains of delegations via redelegations, it's important to understand how authority flows and can be restricted.

Caveats applied to a chain of delegations are accumulative—they stack on top of each other:

Each delegation in the chain inherits all restrictions from its parent delegation.
New caveats can add further restrictions, but can't remove existing ones.
This means that a delegate can only redelegate with equal or lesser authority than they received.

Example: Narrowing permissions
Imagine a simple financial delegation scenario:

Alice delegates to Bob, allowing him to withdraw up to 100 USDC on her behalf.
Bob re-delegates to Carol, but limits the permission to:
Only 50 USDC (reducing the amount).
Only before the end of the week (adding a time constraint).
Carol now has a more restricted version of Alice's original delegation. Bob couldn't give Carol more authority than he had (such as allowing her to withdraw 200 USDC), but he could narrow the permission.
Configure the Delegation Toolkit
The MetaMask Delegation toolkit is highly configurable, providing support for custom bundlers and paymasters. You can also configure the toolkit environment to interact with the Delegation Framework.

Prerequisites
Install and set up the Delegation Toolkit.

Configure the bundler
The toolkit uses Viem's Account Abstraction API to configure custom bundlers and paymasters. This provides a robust and flexible foundation for creating and managing MetaMask Smart Accounts. See Viem's account abstraction documentation for more information on the API's features, methods, and best practices.

To use the bundler and paymaster clients with the toolkit, create instances of these clients and configure them as follows:

import {
  createPaymasterClient,
  createBundlerClient,
} from "viem/account-abstraction";
import { http } from "viem";
import { sepolia as chain } from "viem/chains"; 

// Replace these URLs with your actual bundler and paymaster endpoints.
const bundlerUrl = "https://your-bundler-url.com";
const paymasterUrl = "https://your-paymaster-url.com";

// The paymaster is optional.
const paymasterClient = createPaymasterClient({
  transport: http(paymasterUrl),
});

const bundlerClient = createBundlerClient({
  transport: http(bundlerUrl),
  paymaster: paymasterClient,
  chain,
});
Replace the bundler and paymaster URLs with your bundler and paymaster endpoints. For example, you can use endpoints from Pimlico, Infura, or ZeroDev.

note
Providing a paymaster is optional when configuring your bundler client. However, if you choose not to use a paymaster, the smart contract account must have enough funds to pay gas fees.

(Optional) Configure the toolkit environment
The toolkit environment (DeleGatorEnvironment) defines the contract addresses necessary for interacting with the Delegation Framework on a specific network. It serves several key purposes:

It provides a centralized configuration for all the contract addresses required by the Delegation Framework.
It enables easy switching between different networks (for example, Mainnet and testnet) or custom deployments.
It ensures consistency across different parts of the application that interact with the Delegation Framework.
Resolve the environment
When you create a MetaMask smart account, the toolkit automatically resolves the environment based on the version it requires and the chain configured. If no environment is found for the specified chain, it throws an error.

example.ts
config.ts
import { DeleGatorEnvironment } from "@metamask/delegation-toolkit";
import { delegatorSmartAccount } from "./config.ts";

const environment: DeleGatorEnvironment = delegatorSmartAccount.environment; 
note
See the changelog of the toolkit version you are using (in the left sidebar) for supported chains.

Alternatively, you can use the getDelegatorEnvironment function to resolve the environment. This function is especially useful if your delegator is not a smart account when creating a redelegation.

import { 
  getDeleGatorEnvironment, 
  DeleGatorEnvironment, 
} from "@metamask/delegation-toolkit"; 

// Resolves the DeleGatorEnvironment for Sepolia
const environment: DeleGatorEnvironment = getDelegatorEnvironment(11155111);
Deploy a custom environment
You can deploy the contracts using any method, but the toolkit provides a convenient deployDelegatorEnvironment function. This function simplifies deploying the Delegation Framework contracts to your desired EVM chain.

This function requires a Viem Public Client, Wallet Client, and Chain to deploy the contracts and resolve the DeleGatorEnvironment.

Your wallet must have a sufficient native token balance to deploy the contracts.

example.ts
config.ts
import { walletClient, publicClient } from "./config.ts";
import { sepolia as chain } from "viem/chains";
import { deployDeleGatorEnvironment } from "@metamask/delegation-toolkit/utils";

const environment = await deployDeleGatorEnvironment(
  walletClient, 
  publicClient, 
  chain
);
You can also override specific contracts when calling deployDelegatorEnvironment. For example, if you've already deployed the EntryPoint contract on the target chain, you can pass the contract address to the function.

// The config.ts is the same as in the previous example.
import { walletClient, publicClient } from "./config.ts";
import { sepolia as chain } from "viem/chains";
import { deployDeleGatorEnvironment } from "@metamask/delegation-toolkit/utils";

const environment = await deployDeleGatorEnvironment(
  walletClient, 
  publicClient, 
  chain,
+ {
+   EntryPoint: "0x0000000071727De22E5E9d8BAf0edAc6f37da032"
+ }
);
Once the contracts are deployed, you can use them to override the environment.

Override the environment
To override the environment, the toolkit provides an overrideDeployedEnvironment function to resolve DeleGatorEnvironment with specified contracts for the given chain and contract version.

// The config.ts is the same as in the previous example.
import { walletClient, publicClient } from "./config.ts";
import { sepolia as chain } from "viem/chains";
import { DeleGatorEnvironment } from "@metamask/delegation-toolkit";
import { 
  overrideDeployedEnvironment,
  deployDeleGatorEnvironment 
} from "@metamask/delegation-toolkit/utils";

const environment: DeleGatorEnvironment = await deployDeleGatorEnvironment(
  walletClient, 
  publicClient, 
  chain
);

overrideDeployedEnvironment(
  chain.id,
  "1.3.0",
  environment,
);
If you've already deployed the contracts using a different method, you can create a DelegatorEnvironment instance with the required contract addresses, and pass it to the function.

- import { walletClient, publicClient } from "./config.ts";
- import { sepolia as chain } from "viem/chains";
import { DeleGatorEnvironment } from "@metamask/delegation-toolkit";
import { 
  overrideDeployedEnvironment,
- deployDeleGatorEnvironment
} from "@metamask/delegation-toolkit/utils";

- const environment: DeleGatorEnvironment = await deployDeleGatorEnvironment(
-  walletClient, 
-  publicClient, 
-  chain
- );

+ const environment: DeleGatorEnvironment = {
+  SimpleFactory: "0x124..",
+  // ...
+  implementations: {
+    // ...
+  },
+ };

overrideDeployedEnvironment(
  chain.id,
  "1.3.0",
  environment
);
note
Make sure to specify the Delegation Framework version required by the toolkit. See the changelog of the toolkit version you are using (in the left sidebar) for its required Framework version.
Create a smart account
You can enable users to create a MetaMask smart account directly in your dapp. This page provides examples of using toMetaMaskSmartAccount with Viem Core SDK to create different types of smart accounts with different signature schemes. An account's supported signatories can sign data on behalf of the smart account.

Prerequisites
Install and set up the Delegation Toolkit.

Create a Hybrid smart account
A Hybrid smart account supports both an externally owned account (EOA) owner and any number of passkey (WebAuthn) signers. You can create a Hybrid smart account with the following types of signers.

Create a Hybrid smart account with an Account signer
Use toMetaMaskSmartAccount, and Viem's privateKeyToAccount and generatePrivateKey, to create a Hybrid smart account with a signer from a randomly generated private key:

example.ts
client.ts
signer.ts
import { publicClient } from "./client.ts"
import { account } from "./signer.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: "0x",
  signer: { account },
});
Create a Hybrid smart account with a Wallet Client signer
Use toMetaMaskSmartAccount and Viem's createWalletClient to create a Hybrid smart account with a Wallet Client signer:

example.ts
client.ts
signer.ts
import { publicClient } from "./client.ts"
import { walletClient } from "./signer.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const addresses = await walletClient.getAddresses();
const owner = addresses[0];

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [owner, [], [], []],
  deploySalt: "0x",
  signer: { walletClient },
});
Create a Hybrid smart account with a passkey signer
Use toMetaMaskSmartAccount and Viem's toWebAuthnAccount to create a Hybrid smart account with a passkey (WebAuthn) signer:

Installation required
To work with WebAuthn, install the Ox SDK.

example.ts
client.ts
signer.ts
import { publicClient } from "./client.ts"
import { webAuthnAccount, credential } from "./signer.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";
import { Address, PublicKey } from "ox";
import { toHex } from "viem";

// Deserialize compressed public key
const publicKey = PublicKey.fromHex(credential.publicKey);

// Convert public key to address
const owner = Address.fromPublicKey(publicKey);

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [owner, [credential.id], [publicKey.x], [publicKey.y]],
  deploySalt: "0x",
  signer: { webAuthnAccount, keyId: toHex(credential.id) },
});
Create a Multisig smart account
A Multisig smart account supports multiple EOA signers with a configurable threshold for execution. Use toMetaMaskSmartAccount to create a Multsig smart account with a combination of account signers and Wallet Client signers:

example.ts
client.ts
signers.ts
import { publicClient } from "./client.ts";
import { account, walletClient } from "./signers.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const owners = [ account.address, walletClient.address ];
const signer = [ { account }, { walletClient } ];
const threshold = 2n

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.MultiSig,
  deployParams: [owners, threshold],
  deploySalt: "0x",
  signer,
});
note
The number of signers in the signatories must be at least equal to the threshold for valid signature generation.

Create a Stateless 7702 smart account
A Stateless 7702 smart account represents an EOA that has been upgraded to support MetaMask Smart Accounts functionality as defined by EIP-7702.

note
This implementation does not handle the upgrade process; see the EIP-7702 quickstart to learn how to upgrade.

You can create a Stateless 7702 smart account with the following types of signatories.

Create a Stateless 7702 smart account with an account signer
Use toMetaMaskSmartAccount and Viem's privateKeyToAccount to create a Stateless 7702 smart account with a signer from a private key:

example.ts
client.ts
signer.ts
import { publicClient } from "./client.ts";
import { account } from "./signer.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Stateless7702,
  address: account.address // Address of the upgraded EOA
  signer: { account },
});
Create a Stateless 7702 smart account with a Wallet Client signer
Use toMetaMaskSmartAccount and Viem's createWalletClient to create a Stateless 7702 smart account with a Wallet Client signer:

example.ts
client.ts
signer.ts
import { publicClient } from "./client.ts";
import { walletClient } from "./signer.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const addresses = await walletClient.getAddresses();
const address = addresses[0];

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Stateless7702,
  address, // Address of the upgraded EOA
  signer: { walletClient },
});
Next steps
With a MetaMask smart account, you can perform the following functions:

In conjunction with Viem Account Abstraction clients, deploy the smart account and send user operations.
Create delegations that can be used to grant specific rights and permissions to other accounts. Smart accounts that create delegations are called delegator accounts.
Deploy a smart account
You can deploy MetaMask Smart Accounts in two different ways. You can either deploy a smart account automatically when sending the first user operation, or manually deploy the account.

Prerequisites
Install and set up the Delegation Toolkit.
Create a MetaMask smart account.
Deploy with the first user operation
When you send the first user operation from a smart account, the Delegation Toolkit checks whether the account is already deployed. If the account is not deployed, the toolkit adds the initCode to the user operation to deploy the account within the same operation. Internally, the initCode is encoded using the factory and factoryData.

example.ts
config.ts
import { bundlerClient, smartAccount } from "./config.ts";
import { parseEther } from "viem";

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1")
    }
  ],
  maxFeePerGas,
  maxPriorityFeePerGas
});
Deploy manually
To deploy a smart account manually, call the getFactoryArgs method from the smart account to retrieve the factory and factoryData. This allows you to use a relay account to sponsor the deployment without needing a paymaster.

The factory represents the contract address responsible for deploying the smart account, while factoryData contains the calldata that will be executed by the factory to deploy the smart account.

The relay account can be either an externally owned account (EOA) or another smart account. This example uses an EOA.

example.ts
config.ts
import { walletClient, smartAccount } from "./config.ts";

const { factory, factoryData } = await smartAccount.getFactoryArgs();

// Deploy smart account using relay account.
const hash = await walletClient.sendTransaction({
  to: factory,
  data: factoryData,
})
Next steps
Learn more about sending user operations.
To sponsor gas for end users, see how to send a gasless transaction.
Send a user operation
User operations are the ERC-4337 counterpart to traditional blockchain transactions. They incorporate significant enhancements that improve user experience and provide greater flexibility in account management and transaction execution.

Viem's Account Abstraction API allows a developer to specify an array of Calls that will be executed as a user operation via Viem's sendUserOperation method. The MetaMask Delegation Toolkit encodes and executes the provided calls.

User operations are not directly sent to the network. Instead, they are sent to a bundler, which validates, optimizes, and aggregates them before network submission. See Viem's Bundler Client for details on how to interact with the bundler.

note
If a user operation is sent from a MetaMask smart account that has not been deployed, the toolkit configures the user operation to automatically deploy the account.

Prerequisites
Install and set up the Delegation Toolkit.
Create a MetaMask smart account.
Send a user operation
The following is a simplified example of sending a user operation using Viem Core SDK. Viem Core SDK offers more granular control for developers who require it.

In the example, a user operation is created with the necessary gas limits.

This user operation is passed to a bundler instance, and the EntryPoint address is retrieved from the client.

example.ts
config.ts
import { bundlerClient, smartAccount } from "./config.ts";
import { parseEther } from "viem";

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1")
    }
  ],
  maxFeePerGas,
  maxPriorityFeePerGas
});
Estimate fee per gas
Different bundlers have different ways to estimate maxFeePerGas and maxPriorityFeePerGas, and can reject requests with insufficient values. The following example updates the previous example to estimate the fees.

This example uses constant values, but the Hello Gator example uses Pimlico's Alto bundler, which fetches user operation gas price using the RPC method pimlico_getUserOperationPrice.

Installation required
To estimate the gas fee for Pimlico's bundler, install the permissionless.js SDK.

example.ts
+ import { createPimlicoClient } from "permissionless/clients/pimlico";
import { parseEther } from "viem";
import { bundlerClient, smartAccount } from "./config.ts" // The config.ts is the same as in the previous example.

- const maxFeePerGas = 1n;
- const maxPriorityFeePerGas = 1n;

+ const pimlicoClient = createPimlicoClient({
+   transport: http("https://api.pimlico.io/v2/11155111/rpc"), // You can get the API Key from the Pimlico dashboard.
+ });
+
+ const { fast: fee } = await pimlicoClient.getUserOperationGasPrice();

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1")
    }
  ],
-  maxFeePerGas,
-  maxPriorityFeePerGas
+  ...fee
});
Wait for the transaction receipt
After submitting the user operation, it's crucial to wait for the receipt to ensure that it has been successfully included in the blockchain. Use the waitForUserOperationReceipt method provided by the bundler client.

example.ts
import { createPimlicoClient } from "permissionless/clients/pimlico";
import { bundlerClient, smartAccount } from "./config.ts" // The config.ts is the same as in the previous example.

const pimlicoClient = createPimlicoClient({
  transport: http("https://api.pimlico.io/v2/11155111/rpc"), // You can get the API Key from the Pimlico dashboard.
});

const { fast: fee } = await pimlicoClient.getUserOperationGasPrice();

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1")
    }
  ],
  ...fee
});

+ const { receipt } = await bundlerClient.waitForUserOperationReceipt({
+   hash: userOperationHash
+ });
+
+ console.log(receipt.transactionHash);
Next steps
To sponsor gas for end users, see how to send a gasless transaction.
Send a gasless transaction
MetaMask Smart Accounts support gas sponsorship, which simplifies onboarding by abstracting gas fees away from end users. You can use any paymaster service provider, such as Pimlico or ZeroDev, or plug in your own custom paymaster.

Prerequisites
Install and set up the Delegation Toolkit.
Create a MetaMask smart account.
Send a gasless transaction
The following example demonstrates how to use Viem's Paymaster Client to send gasless transactions. You can provide the paymaster client using the paymaster property in the sendUserOperation method, or in the Bundler Client.

In this example, the paymaster client is passed to the sendUserOperation method.

example.ts
config.ts
import { bundlerClient, smartAccount, paymasterClient } from "./config.ts";
import { parseEther } from "viem";

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1")
    }
  ],
  maxFeePerGas,
  maxPriorityFeePerGas,
  paymaster: paymasterClient,
});
Generate a multisig signature
The MetaMask Delegation Toolkit supports Multisig smart accounts, allowing you to add multiple externally owned accounts (EOA) signers with a configurable execution threshold. When the threshold is greater than 1, you can collect signatures from the required signers and use the aggregateSignature function to combine them into a single aggregated signature.

Prerequisites
Install and set up the Delegation Toolkit.
Create a Multisig smart account.
Generate a multisig signature
The following example configures a Multisig smart account with two different signers: Alice and Bob. The account has a threshold of 2, meaning that signatures from both parties are required for any execution.

example.ts
config.ts
import { 
  bundlerClient, 
  aliceSmartAccount, 
  bobSmartAccount,
  aliceAccount,
  bobAccount,
} from "./config.ts";
import { aggregateSignature } from "@metamask/delegation-toolkit";

const userOperation = await bundlerClient.prepareUserOperation({
  account: aliceSmartAccount,
  calls: [
    {
      target: zeroAddress,
      value: 0n,
      data: "0x",
    }
  ]
});

const aliceSignature = await aliceSmartAccount.signUserOperation(userOperation);
const bobSignature = await bobSmartAccount.signUserOperation(userOperation);

const aggregatedSignature = aggregateSignature({
  signatures: [{
    signer: aliceAccount.address,
    signature: aliceSignature,
    type: "ECDSA",
  }, {
    signer: bobAccount.address,
    signature: bobSignature,
    type: "ECDSA",
  }],
});
Perform executions on a smart account's behalf
Delegation is the ability for a MetaMask smart account to grant permission to another account to perform executions on its behalf.

In this guide, you'll create a delegator account (Alice) and a delegate account (Bob), and grant Bob permission to perform executions on Alice's behalf. You'll complete the delegation lifecycle (create, sign, and redeem a delegation).

Prerequisites
Install and set up the Delegation Toolkit.

Steps
1. Create a Public Client
Create a Viem Public Client using Viem's createPublicClient function. You will configure Alice's account (the delegator) and the Bundler Client with the Public Client, which you can use to query the signer's account state and interact with smart contracts.

import { createPublicClient, http } from "viem"
import { sepolia as chain } from "viem/chains"

const publicClient = createPublicClient({
  chain,
  transport: http(),
})
2. Create a Bundler Client
Create a Viem Bundler Client using Viem's createBundlerClient function. You can use the bundler service to estimate gas for user operations and submit transactions to the network.

import { createBundlerClient } from "viem/account-abstraction"

const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://your-bundler-rpc.com"),
})
3. Create a delegator account
Create an account to represent Alice, the delegator who will create a delegation. The delegator must be a MetaMask smart account; use the toolkit's toMetaMaskSmartAccount method to create the delegator account.

A Hybrid smart account is a flexible smart account implementation that supports both an externally owned account (EOA) owner and any number of P256 (passkey) signers. This examples configures a Hybrid smart account with an Account signer:

import { Implementation, toMetaMaskSmartAccount } from "@metamask/delegation-toolkit"
import { privateKeyToAccount } from "viem/accounts"

const delegatorAccount = privateKeyToAccount("0x...")

const delegatorSmartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [delegatorAccount.address, [], [], []],
  deploySalt: "0x",
  signer: { account: delegatorAccount },
})
note
See how to configure other smart account types.

4. Create a delegate account
Create an account to represent Bob, the delegate who will receive the delegation. The delegate can be a smart account or an externally owned account (EOA):

Smart account
EOA
import { Implementation, toMetaMaskSmartAccount } from "@metamask/delegation-toolkit"
import { privateKeyToAccount } from "viem/accounts"

const delegateAccount = privateKeyToAccount("0x...")

const delegateSmartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid, // Hybrid smart account
  deployParams: [delegateAccount.address, [], [], []],
  deploySalt: "0x",
  signer: { account: delegateAccount },
})
5. Create a delegation
Create a root delegation from Alice to Bob. With a root delegation, Alice is delegating her own authority away, as opposed to redelegating permissions she received from a previous delegation.

Use the toolkit's createDelegation method to create a root delegation. When creating delegation, you need to configure the scope of the delegation to define the initial authority.

This example uses the erc20TransferAmount scope, allowing Alice to delegate to Bob the ability to spend her USDC, with a specified limit on the total amount.

Important
Before creating a delegation, ensure that the delegator account (in this example, Alice's account) has been deployed. If the account is not deployed, redeeming the delegation will fail.

import { createDelegation } from "@metamask/delegation-toolkit"

// USDC address on Ethereum Sepolia.
const tokenAddress = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";

const delegation = createDelegation({
  to: delegateSmartAccount.address, // This example uses a delegate smart account
  from: delegatorSmartAccount.address,
  environment: delegatorSmartAccount.environment
  scope: {
    type: "erc20TransferAmount",
    tokenAddress,
    maxAmount: 10000000n,
  },
})
6. Sign the delegation
Sign the delegation with Alice's account, using the signDelegation method from MetaMaskSmartAccount. Alternatively, you can use the toolkit's signDelegation utility method. Bob will later use the signed delegation to perform actions on Alice's behalf.

const signature = await delegatorSmartAccount.signDelegation({
  delegation,
})

const signedDelegation = {
  ...delegation,
  signature,
}
7. Redeem the delegation
Bob can now redeem the delegation. The redeem transaction is sent to the DelegationManager contract, which validates the delegation and executes actions on Alice's behalf.

To prepare the calldata for the redeem transaction, use the redeemDelegations method from DelegationManager. Since Bob is redeeming a single delegation chain, use the SingleDefault execution mode.

Bob can redeem the delegation by submitting a user operation if his account is a smart account, or a regular transaction if his account is an EOA:

Redeem with a smart account
Redeem with an EOA
import { createExecution, ExecutionMode } from "@metamask/delegation-toolkit"
import { DelegationManager } from "@metamask/delegation-toolkit/contracts"
import { zeroAddress } from "viem"

const delegations = [signedDelegation]

const executions = createExecution({ target: zeroAddress })

const redeemDelegationCalldata = DelegationManager.encode.redeemDelegations({
  delegations: [delegations],
  modes: [ExecutionMode.SingleDefault],
  executions: [executions],
})

const userOperationHash = await bundlerClient.sendUserOperation({
  account: delegateSmartAccount,
  calls: [
    {
      to: delegateSmartAccount.address,
      data: redeemDelegationCalldata,
    },
  ],
  maxFeePerGas: 1n,
  maxPriorityFeePerGas: 1n,
})
Next steps
See how to configure different scopes to define the initial authority of a delegation.
See how to further refine the authority of a delegation using caveat enforcers.
Use delegation scopes
When creating a delegation, you can configure a scope to define the delegation's initial authority and help prevent delegation misuse. You can further constrain this initial authority by adding caveats to a delegation.

The Delegation Toolkit currently supports three categories of scopes:

Scope type	Description
Spending limit scopes	Restricts the spending of native, ERC-20, and ERC-721 tokens based on defined conditions.
Function call scope	Restricts the delegation to specific contract methods, contract addresses, or calldata.
Ownership transfer scope	Restricts the delegation to only allow ownership transfers, specifically the transferOwnership function for a specified contract.
Use spending limit scopes
Spending limit scopes define how much a delegate can spend in native, ERC-20, or ERC-721 tokens. You can set transfer limits with or without time-based (periodic) or streaming conditions, depending on your use case.

Prerequisites
Install and set up the Delegation Toolkit.
Configure the Delegation Toolkit.
Create a delegator account.
Create a delegate account.
ERC-20 periodic scope
This scope ensures a per-period limit for ERC-20 token transfers. You set the amount and the time window. At the start of each new period, the allowance resets. For example, Alice creates a delegation that lets Bob spend up to 10 USDC on her behalf each day. Bob can transfer a total of 10 USDC per day; the limit resets at the beginning of the next day.

When this scope is applied, the toolkit automatically disallows native token transfers (sets the native token transfer limit to 0).

Internally, this scope uses the erc20PeriodTransfer and valueLte caveat enforcers.

import { createDelegation } from "@metamask/delegation-toolkit";

const delegation = createDelegation({
  scope: {
    type: "erc20PeriodTransfer",
    tokenAddress: "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
    periodAmount: 1000000000000000000n,
    periodDuration: 86400,
    startDate: 1743763600,
  },
  to: delegateAccount,
  from: delegatorAccount,
  environment: delegatorAccount.environment,
});
ERC-20 streaming scope
This scopes ensures a linear streaming transfer limit for ERC-20 tokens. Token transfers are blocked until the defined start timestamp. At the start, a specified initial amount is released, after which tokens accrue linearly at the configured rate, up to the maximum allowed amount. For example, Alice creates a delegation that allows Bob to spend 0.1 USDC per second, starting with an initial amount of 10 USDC, up to a maximum of 100 USDC.

When this scope is applied, the toolkit automatically disallows native token transfers (sets the native token transfer limit to 0).

Internally, this scope uses the erc20Streaming and valueLte caveat enforcers.

import { createDelegation } from "@metamask/delegation-toolkit";

const delegation = createDelegation({
  scope: {
    type: "erc20Streaming",
    tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
    amountPerSecond: 100n,
    initialAmount: 1000000n,
    maxAmount: 10000000n,
    startTime: 1703980800,
  },
  to: delegateAccount,
  from: delegatorAccount,
  environment: delegatorAccount.environment,
});
ERC-20 transfer scope
This scope ensures that ERC-20 token transfers are limited to a predefined maximum amount. This scope is useful for setting simple, fixed transfer limits without any time based or streaming conditions. For example, Alice creates a delegation that allows Bob to spend up to 10 USDC without any conditions. Bob may use the 10 USDC in a single transaction or make multiple transactions, as long as the total does not exceed 10 USDC.

When this scope is applied, the toolkit automatically disallows native token transfers (sets the native token transfer limit to 0).

Internally, this scope uses the erc20TransferAmount and valueLte caveat enforcers.

import { createDelegation } from "@metamask/delegation-toolkit";

const delegation = createDelegation({
  scope: {
    type: "erc20TransferAmount",
    tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
    maxAmount: 10000n,
  },
  to: delegateAccount,
  from: delegatorAccount,
  environment: delegatorAccount.environment,
});
ERC-721 scope
This scope limits the delegation to ERC-721 token transfers only. For example, Alice creates a delegation that allows Bob to transfer an NFT she owns on her behalf.

Internally, this scope uses the erc721Transfer caveat enforcer.

import { createDelegation } from "@metamask/delegation-toolkit";

const delegation = createDelegation({
  scope: {
    type: "erc721Transfer",
    tokenAddress: "0x3fF528De37cd95b67845C1c55303e7685c72F319",
    tokenId: 1n,
  },
  to: delegateAccount,
  from: delegatorAccount,
  environment: delegatorAccount.environment,
});
Native token periodic scope
This scope ensures a per-period limit for native token transfers. You set the amount and the time window. At the start of each new period, the allowance resets. For example, Alice creates a delegation that lets Bob spend up to 0.01 ETH on her behalf each day. Bob can transfer a total of 0.01 ETH per day; the limit resets at the beginning of the next day.

When this scope is applied, the toolkit disallows ERC-20 and ERC-721 token transfers by default, setting the allowed calldata to 0x.

Internally, this scope uses the exactCalldata and nativeTokenPeriodTransfer caveat enforcers.

import { createDelegation } from "@metamask/delegation-toolkit";

const delegation = createDelegation({
  scope: {
    type: "nativeTokenPeriodTransfer",
    periodAmount: 1000000000000000000n,
    periodDuration: 86400,
    startDate: 1743763600,
  },
  to: delegateAccount,
  from: delegatorAccount,
  environment: delegatorAccount.environment,
});
Native token streaming scope
This scopes ensures a linear streaming transfer limit for native tokens. Token transfers are blocked until the defined start timestamp. At the start, a specified initial amount is released, after which tokens accrue linearly at the configured rate, up to the maximum allowed amount. For example, Alice creates delegation that allows Bob to spend 0.001 ETH per second, starting with an initial amount of 0.01 ETH, up to a maximum of 0.1 ETH.

When this scope is applied, the toolkit disallows ERC-20 and ERC-721 token transfers by default, setting the allowed calldata to 0x.

Internally, this scope uses the exactCalldata and nativeTokenStreaming caveat enforcers.

import { createDelegation } from "@metamask/delegation-toolkit";

const delegation = createDelegation({
  scope: {
    type: "nativeTokenStreaming",
    amountPerSecond: 100n,
    initialAmount: 1000000n,
    maxAmount: 10000000n,
    startTime: 1703980800,
  },
  to: delegateAccount,
  from: delegatorAccount,
  environment: delegatorAccount.environment,
});
Native token transfer scope
This scope ensures that native token transfers are limited to a predefined maximum amount. This scope is useful for setting simple, fixed transfer limits without any time based or streaming conditions. For example, Alice creates a delegation that allows Bob to spend up to 0.1 ETH without any conditions. Bob may use the 0.1 ETH in a single transaction or make multiple transactions, as long as the total does not exceed 0.1 ETH.

When this scope is applied, the toolkit disallows ERC-20 and ERC-721 token transfers by default, setting the allowed calldata to 0x.

Internally, this scope uses the exactCalldata and nativeTokenTransferAmount caveat enforcers.

import { createDelegation } from "@metamask/delegation-toolkit";

const delegation = createDelegation({
  scope: {
    type: "nativeTokenTransferAmount",
    // 0.001 ETH in wei format.
    maxAmount: 1000000000000000n,
  },
  to: delegateAccount,
  from: delegatorAccount,
  environment: delegatorAccount.environment,
});
Next steps
See how to further constrain the authority of a delegation using caveat enforcers.
Use the function call scope
The function call scope defines the specific methods, contract addresses, and calldata that are allowed for the delegation. For example, Alice delegates to Bob the ability to call the approve function on the USDC contract, with the approval amount set to 0.

Internally, this scope uses the allowedTargets and allowedMethods caveat enforcers, and optionally uses the allowedCalldata or exactCalldata caveat enforcers when those parameters are specified.

Prerequisites
Install and set up the Delegation Toolkit.
Configure the Delegation Toolkit.
Create a delegator account.
Create a delegate account.
Function call scope
This scope requires targets and selectors as mandatory parameters for the configuration. You can specify the allowed methods in selectors and the permitted contract addresses in targets.

The following example sets the delegation scope to allow the delegate to call the approve function on the USDC token contract.

import { createDelegation } from "@metamask/delegation-toolkit";

// USDC address on Sepolia.
const USDC_ADDRESS = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238"

const delegation = createDelegation({
  scope: {
    type: "functionCall",
    targets: [USDC_ADDRESS],
    selectors: ["approve(address, uint256)"]
  },
  to: delegateAccount,
  from: delegatorAccount,
  environment: delegatorAccount.environment,
});
Next steps
See how to further constrain the authority of a delegation using caveat enforcers.
Use the ownership transfer scope
The ownership transfer scope restricts a delegation to ownership transfer calls only. For example, Alice has deployed a smart contract, and she delegates to Bob the ability to transfer ownership of that contract.

Internally, this scope uses the ownershipTransfer caveat enforcer.

Prerequisites
Install and set up the Delegation Toolkit.
Configure the Delegation Toolkit.
Create a delegator account.
Create a delegate account.
Ownership transfer scope
This scope requires a contractAddress, which represents the address of the deployed contract.

import { createDelegation } from "@metamask/delegation-toolkit";

const contractAddress = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238"

const delegation = createDelegation({
  scope: {
    type: "ownershipTransfer",
    contractAddress,
  },
  to: delegateAccount,
  from: delegatorAccount,
  environment: delegatorAccount.environment,
});
Next steps
See how to further constrain the authority of a delegation using caveat enforcers.
Constrain a delegation scope
Delegation scopes define the delegation's initial authority and help prevent delegation misuse. You can further constrain these scopes and limit the delegation's authority by applying caveat enforcers.

Prerequisites
Configure a delegation scope.

Apply a caveat enforcer
For example, Alice creates a delegation with an ERC-20 transfer scope that allows Bob to spend up to 10 USDC. If Alice wants to further restrict the scope to limit Bob's delegation to be valid for only seven days, she can apply the timestamp caveat enforcer.

The following example creates a delegation using createDelegation, applies the ERC-20 transfer scope with a spending limit of 10 USDC, and applies the timestamp caveat enforcer to restrict the delegation's validity to a seven-day period:

import { createDelegation } from "@metamask/delegation-toolkit";

// Convert milliseconds to seconds.
const currentTime = Math.floor(Date.now() / 1000);

// Seven days after current time.
const beforeThreshold = currentTime + 604800;

const caveats = [{
  type: "timestamp",
  afterThreshold: currentTime,
  beforeThreshold, 
}];

const delegation = createDelegation({
  scope: {
    type: "erc20TransferAmount",
    tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
    maxAmount: 10000n,
  },
  // Apply caveats to the delegation.
  caveats,
  to: delegateAccount,
  from: delegatorAccount,
  environment: delegatorAccount.environment,
});
Next steps
See the caveats reference for the full list of caveat types and their parameters.
For more specific or custom control, you can also create custom caveat enforcers and apply them to delegations.
Check the delegation state
When using spending limit delegation scopes or relevant caveat enforcers, you might need to check the remaining transferrable amount in a delegation. For example, if a delegation allows a user to spend 10 USDC per week and they have already spent 10 - n USDC in the current period, you can determine how much of the allowance is still available for transfer.

Use the CaveatEnforcerClient to check the available balances for specific scopes or caveats.

Prerequisites
Install and set up the Delegation Toolkit.
Create a delegator account.
Create a delegate account.
Create a delegation with an ERC-20 periodic scope.
Create a CaveatEnforcerClient
To check the delegation state, create a CaveatEnforcerClient. This client allows you to interact with the caveat enforcers of the delegation, and read the required state.

example.ts
config.ts
import { environment, publicClient as client } from './config.ts'
import { createCaveatEnforcerClient } from '@metamask/delegation-toolkit'

const caveatEnforcerClient = createCaveatEnforcerClient({
  environment,
  client,
})
Read the caveat enforcer state
This example uses the getErc20PeriodTransferEnforcerAvailableAmount method to read the state and retrieve the remaining amount for the current transfer period.

example.ts
config.ts
import { delegation } './config.ts'

// Returns the available amount for current period. 
const { availableAmount } = await caveatEnforcerClient.getErc20PeriodTransferEnforcerAvailableAmount({
  delegation,
})
Next steps
See the Caveat Enforcer Client reference for the full list of available methods.
Use an ERC-20 paymaster with a smart account
delegation toolkit
ERC-20 paymaster
smart accounts
MetaMask Developer Relations | Sep 2, 2025
This tutorial walks you through using an ERC-20 paymaster with MetaMask Smart Accounts, enabling users to pay gas fees in USDC. This tutorial uses Pimlico's paymaster, but you can use any paymaster of your choice.

About paymasters
A paymaster is an important component of the account abstraction (ERC-4337) standard, responsible for abstracting gas fees for end users. There are different types of paymasters, such as gasless paymasters and ERC-20 paymasters. While a gasless paymaster covers the transaction on behalf of the user, an ERC-20 paymaster allows users to pay gas fees using a supported ERC-20 token. This removes the need for users to hold native tokens, allowing them to perform onchain actions using only stablecoins.

Prerequisites
Install Node.js v18 or later.
Install Yarn, npm, or another package manager.
Create a Pimlico API key.
Steps
1. Install the toolkit
Install the MetaMask Delegation Toolkit in your project:

npm
Yarn
pnpm
Bun
npm install @metamask/delegation-toolkit
2. Create a Public Client
Create a Viem Public Client using Viem's createPublicClient function. You will configure a smart account and Bundler Client with the Public Client, which you can use to query the signer's account state and interact with the blockchain network.

import { createPublicClient, http } from "viem";
import { sepolia as chain } from "viem/chains";

const publicClient = createPublicClient({
  chain,
  transport: http(),
});
3. Create a Paymaster Client
Create a Viem Paymaster Client using Viem's createPaymasterClient function. This client interacts with the paymaster service, enabling users to pay gas fees in USDC.

Replace <YOUR-API-KEY> with your Pimlico API key:

import { createPaymasterClient } from "viem/account-abstraction";

const paymasterClient = createPaymasterClient({
  transport: http("https://api.pimlico.io/v2/11155111/rpc?apikey=<YOUR-API-KEY>"),
});
4. Create a Bundler Client
Create a Viem Bundler Client using Viem's createBundlerClient function. You can use the bundler service to estimate gas for user operations and submit transactions to the network.

To use the ERC-20 paymaster, configure the paymasterContext with the ERC-20 token you wish to use to pay for gas fees. For this tutorial, specify the Sepolia USDC token address.

import { createBundlerClient } from "viem/account-abstraction";

// USDC address on Ethereum Sepolia.
const token = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";

const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://your-bundler-rpc.com"),
  paymasterContext: {
    token,
  }
});
5. Create and fund a smart account
Create a Hybrid smart account. A Hybrid smart account is a flexible smart account implementation that supports both an externally owned account (EOA) owner and any number of passkey (WebAuthn) signers.

import { Implementation, toMetaMaskSmartAccount } from "@metamask/delegation-toolkit";
import { privateKeyToAccount } from "viem/accounts";

const account = privateKeyToAccount("0x...");

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: "0x",
  signer: { account },
});
Fund the account with some Sepolia USDC to pay gas fees.

note
You can use Circle's faucet to get Sepolia USDC.

6. Send a user operation
The ERC-20 paymaster works by transferring the token from the smart account, and reimbursing itself for paying the gas fees on the user's behalf.

To send a user operation with the ERC-20 paymaster, use the sendUserOperation method from the Bundler Client. You must include a call approving the ERC-20 token to be used by the paymaster. To modify the token allowance for the paymaster, perform a write operation on the USDC contract. For this tutorial, set an allowance of 10 USDC tokens.

note
In a production dapp, you should first check the existing token allowance and only approve the amount required by the paymaster.

Batch the approve call with other onchain actions you want to perform using the ERC-20 paymaster. Pass the paymasterClient from Step 3 to the paymaster property.

// Appropriate fee per gas must be determined for the bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const pimlicoPaymasterAddress = "0x777777777777AeC03fd955926DbF81597e66834C";

// 10 USDC in wei format. Since USDC has 6 decimals, the wei value is 10 * 10^6.
const approvalAmount = 10000000n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    // USDC approve call
    {
      // USDC token address
      to: token,
      abi: parseAbi(["function approve(address,uint)"]),
      functionName: "approve",
      args: [pimlicoPaymasterAddress, approvalAmount],
    }
    // Batch the approve call with other onchain actions.
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1"),
    },
  ],
  maxFeePerGas,
  maxPriorityFeePerGas,
  paymaster: paymasterClient,
});
Next steps
Learn more about smart account implementations.
To sponsor gas for end users, see how to send a gasless transaction.
Use a passkey as a backup signer
delegation toolkit
passkey
backup signer
smart account
MetaMask Developer Relations | Aug 27, 2025
This tutorial walks you through using a passkey as a backup signer for your MetaMask smart account.

About passkeys
An externally owned account (EOA) uses the secp256k1 elliptic curve to generate key pairs and signatures. In contrast, a passkey (WebAuthn credential) uses the secp256r1 (P-256) elliptic curve to generate key pairs and signatures. Passkeys eliminate the need for traditional seed phrases that are difficult to remember, enabling a more seamless and secure way for users to access their web3 wallets.

MetaMask Smart Accounts offer a Hybrid implementation, which supports signature validation for both secp256k1 and secp256r1 curves. This allows you to add a passkey as a backup signer for your smart account.

You can add passkeys during smart account creation or after the account has been deployed. This tutorial walks you through adding a passkey signer to an already deployed smart account.

Prerequisites
Install Node.js v18 or later.
Install Yarn, npm, or another package manager.
Steps
1. Install dependencies
Install the MetaMask Delegation Toolkit and Ox SDK in your project:

npm
Yarn
pnpm
Bun
npm install @metamask/delegation-toolkit ox
2. Create a Public Client
Create a Viem Public Client using Viem's createPublicClient function. You will configure a smart account and Bundler Client with the Public Client, which you can use to query the signer's account state and interact with the blockchain network.

import { createPublicClient, http } from 'viem'
import { sepolia as chain } from 'viem/chains'

const publicClient = createPublicClient({
  chain,
  transport: http(),
})
3. Create a Bundler Client
Create a Viem Bundler Client using Viem's createBundlerClient function. You can use the bundler service to estimate gas for user operations and submit transactions to the network.

import { createBundlerClient } from 'viem/account-abstraction'

const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http('https://your-bundler-rpc.com'),
})
4. Create and deploy a smart account
Create and deploy a Hybrid smart account, with a private key signer. The Hybrid implementation supports adding additional passkey signers.

import { Implementation, toMetaMaskSmartAccount } from '@metamask/delegation-toolkit'
import { privateKeyToAccount } from 'viem/accounts'
import { zeroAddress } from 'viem'

const account = privateKeyToAccount('0x...')

// Create the smart account.
const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: '0x',
  signer: { account },
})

// Deploy the smart account by sending a user operation.
// Appropriate fee per gas must be determined for the bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [{ to: zeroAddress }],
  maxFeePerGas,
  maxPriorityFeePerGas,
})
5. Create a passkey
To add a passkey signer, use Viem's createWebAuthnCredential function to securely register the passkey (WebAuthn credential).

import { createWebAuthnCredential } from 'viem/account-abstraction'

const credential = await createWebAuthnCredential({
  name: 'MetaMask Smart Account',
})
6. Add the passkey as a backup signer
Use the HybridDeleGator contract namespace from the Delegation Toolkit to encode the calldata required to add the passkey signer. The encoding function needs the X and Y coordinates of the P-256 public key. Since WebAuthn credentials store a compressed public key, you need to use the Ox SDK to deserialize it, and extract the X and Y coordinates.

Once the calldata is prepared, send it to your smart account address to register the passkey as a backup signer.

import { PublicKey } from 'ox'
import { HybridDeleGator, P256Owner } from '@metamask/delegation-toolkit/contracts'

// Deserialize the compressed public key.
const publicKey = PublicKey.fromHex(credential.publicKey)

const p256Owner: P256Owner = {
  keyId: credential.id,
  x: publicKey.x,
  y: publicKey.y,
}

const data = HybridDeleGator.encode.addKey({
  p256Owner,
})

// Appropriate fee per gas must be determined for the bundler being used.
const maxFeePerGas = 1n
const maxPriorityFeePerGas = 1n

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: smartAccount.address,
      data,
    },
  ],
  maxFeePerGas,
  maxPriorityFeePerGas,
})
7. (Optional) Use the passkey signer
You can now use the passkey signer to access your smart account and sign transactions. If you ever lose your primary signer (private key) used in Step 4, you can use the passkey as a secure backup method to retain access to your smart account.

Use the Viem WebAuthn Account to configure your passkey as a MetaMask smart account signer.

import { Address } from 'ox'
import { toWebAuthnAccount } from 'viem/account-abstraction'
import { toHex } from 'viem'
import { Implementation, toMetaMaskSmartAccount } from '@metamask/delegation-toolkit'

// Use the deserialized public key from the previous step.
const owner = Address.fromPublicKey(publicKey)

// Use the credential from the previous step.
const webAuthnAccount = toWebAuthnAccount({ credential })

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [owner, [credential.id], [publicKey.x], [publicKey.y]],
  deploySalt: '0x',
  signer: { webAuthnAccount, keyId: toHex(credential.id) },
})
Next steps
Learn more about smart account implementations.
To sponsor gas fees when adding a passkey as a backup signer, see how to send a gasless transaction.
Create a custom caveat enforcer
delegation toolkit
caveat enforcer
smart contracts
MetaMask Developer Relations | Aug 27, 2025
This tutorial walks you through creating a custom caveat enforcer and applying it to a delegation.

The MetaMask Delegation Toolkit includes out-of-the-box caveat enforcers that define rules and restrictions for common use cases. For more specific control or other use cases, you can create custom caveat enforcers. In this tutorial, you'll create and apply a caveat enforcer that only allows a delegation to be redeemed after a specific timestamp.

Prerequisites
Install Node.js v18 or later.
Install Yarn, npm, or another package manager.
Install Foundry and Forge.
Get an Infura API key from the MetaMask Developer dashboard.
Have a MetaMask account with some Sepolia ETH to deploy your contract.
note
You can use the MetaMask faucet to get Sepolia ETH.

Steps
1. Install the toolkit
Install the MetaMask Delegation Toolkit in your project:

npm
Yarn
pnpm
Bun
npm install @metamask/delegation-toolkit
2. Create the caveat enforcer
At the root of your project, create a contracts directory. In that directory, create a new contract named AfterTimestampEnforcer.sol.

Add the following code to AfterTimestampEnforcer.sol, which creates a caveat enforcer that extends the ICaveatEnforcer.sol interface and only allows a delegation to be redeemed after a specific timestamp:

AfterTimestampEnforcer.sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import { CaveatEnforcer } from "@delegator/src/enforcers/CaveatEnforcer.sol";
import { ModeCode } from "/delegation-toolkit/utils/Types.sol";

contract AfterTimestampEnforcer is CaveatEnforcer {
  /**
   * @notice The delegation may only be redeemed after the specified timestamp - validAfter in seconds.
   * @param _terms The validAfter, timestamp in seconds after which the delegation may be redeemed.
   * @param _delegationHash - The hash of the delegation being operated on.
   */
  function beforeHook(
    bytes calldata _terms,
    bytes calldata,
    ModeCode,
    bytes calldata,
    bytes32 _delegationHash,
    address,
    address _redeemer
  )
    public
    override
  {
    // Enforces the conditions that should hold before a transaction is performed.
    // This function MUST revert if the conditions are not met.
    // Get the current timestamp
    uint256 timestamp = block.timestamp;

    uint256 validAfter = uint256(bytes32(_terms));

    require(timestamp > validAfter, "AfterTimestampEnforcer:cannot-redeem-too-early");
  }
}
3. Deploy the caveat enforcer
Deploy your custom caveat enforcer using Forge to obtain its contract address. Replace <YOUR-API-KEY> with your Infura API key, and <YOUR-PRIVATE-KEY> with the private key of your MetaMask account:

forge create src/AfterTimestampEnforcer.sol:AfterTimestampEnforcer \
  --rpc-url https://sepolia.infura.io/v3/<YOUR-API-KEY>            \
  --private-key <YOUR-PRIVATE-KEY>                                 \
  --broadcast
The Forge CLI will display the address of the deployed caveat enforcer.

4. Apply the caveat enforcer
Specify the address of the deployed AfterTimestampEnforcer.sol contract, add it to the caveat builder, and create a delegation.

The following code snippet uses the custom caveat enforcer to create a delegation granting a 1,000,000 wei allowance that becomes spendable one hour after it is created:

delegation.ts
config.ts
import { createDelegation, ROOT_AUTHORITY } from '@metamask/delegation-toolkit'
import { createCaveatBuilder } from '@metamask/delegation-toolkit/utils'
import { toHex } from 'viem'
import { delegatorSmartAccount } from './config.ts'

const environment = delegatorSmartAccount.environment

// Replace this with the address of the deployed AfterTimestampEnforcer.sol contract.
const afterTimestampEnforcer = '0x22Ae4c4919C3aB4B5FC309713Bf707569B74876F'

const caveatBuilder = createCaveatBuilder(environment)

const tenAM = 10 * 60 * 60 // 10:00 AM as seconds since midnight.

const caveats = caveatBuilder.addCaveat('nativeTokenTransferAmount', 1000000n).addCaveat({
  enforcer: afterTimestampEnforcer,
  terms: toHex(tenAM),
})

const delegation: Delegation =  {
  delegate: "DELEGATE_ADDRESS",
  delegator: delegatorSmartAccount.address,
  authority: ROOT_AUTHORITY,
  caveats: caveats.build(),
  salt: '0x',
};
You've successfully created, deployed, and applied a custom caveat enforcer!

For production use cases, you might need to add additional caveats to restrict the delegation further. Learn more about caveat enforcers.
Create a social invite link
delegation toolkit
embedded wallets
social
invite
referral
link
MetaMask Developer Relations | Sep 8, 2025
This tutorial walks you through creating an invite link so users can refer their friends to your dapp with minimal friction.

For example, Alice (the inviter) wants Bob (the invitee) to try out your dapp. She sends him a link that allows him to claim 0.001 ETH from her wallet within a time limit. Bob can start using your dapp right away, without installing a wallet or paying gas fees.

You'll enable this by:

Adding an embedded wallet for instant onboarding.
Creating a MetaMask smart account to create and redeem an invitation.
Creating an open delegation to represent an invitation.
Prerequisites
Install Node.js v18 or later.
Install Yarn, npm, or another package manager.
Get a Client ID from the Embedded Wallets (Web3Auth) dashboard.
Create a Pimlico API key.
note
This tutorial uses Pimlico's bundler and paymaster, but you can use any bundler and paymaster of your choice.

Steps
1. Set up the project
1.1. Install dependencies
Install the MetaMask Delegation Toolkit and other dependencies in your project:

npm
Yarn
pnpm
Bun
npm install @metamask/delegation-toolkit @web3auth/modal wagmi @tanstack/react-query
1.2. Set up Embedded Wallets (Web3Auth)
Configure MetaMask Embedded Wallets (Web3Auth) to enable users to instantly connect to your dapp using familiar login methods, like social accounts or email.

Add a WEB3AUTH_CLIENT_ID environment variable, replacing <YOUR-CLIENT-ID> with your Web3Auth Client ID:

.env.local
WEB3AUTH_CLIENT_ID=<YOUR-CLIENT-ID>
Configure Web3Auth options:

providers/AppProvider.tsx
import { WEB3AUTH_NETWORK, Web3AuthOptions } from '@web3auth/modal';

const web3AuthOptions: Web3AuthOptions = {
  clientId: process.env.WEB3AUTH_CLIENT_ID as string,
  web3AuthNetwork: WEB3AUTH_NETWORK.SAPPHIRE_MAINNET,
};

const web3authConfig = {
  web3AuthOptions,
};
Create a connect button:

components/ConnectButton.tsx
import { useWeb3AuthConnect } from '@web3auth/modal/react';
import Button from '@/components/Button'; // You can add your own Button component

export default function ConnectButton() {
  const { connect } = useWeb3AuthConnect();

  return (
    <div className='flex gap-2'>
      <Button onClick={() => connect()}>Connect with Web3Auth</Button>
    </div>
  );
}
1.3. Set up Wagmi
Wrap your dapp with the Wagmi, Web3Auth, and React Query providers. Add Wagmi using the Web3Auth Wagmi adapter so wallet connections from Web3Auth are available to Wagmi hooks.

providers/AppProvider.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Web3AuthProvider } from '@web3auth/modal/react';
import { WagmiProvider } from '@web3auth/modal/react/wagmi';

const queryClient = new QueryClient();

export function AppProvider({ children }: { children: React.ReactNode }) {
  return (
    <Web3AuthProvider config={web3authConfig}>
      <QueryClientProvider client={queryClient}>
        <WagmiProvider>{children}</WagmiProvider>
      </QueryClientProvider>
    </Web3AuthProvider>
  );
}
2. Create a Bundler Client
Create a Viem Bundler Client using Viem's createBundlerClient function. You can use the bundler service to estimate gas for user operations and submit transactions to the network.

Set paymaster to true to use the Pimlico paymaster with the Bundler Client, and replace <YOUR-API-KEY> with your Pimlico API key:

import { createBundlerClient } from 'viem/account-abstraction';
import { usePublicClient } from "wagmi";

const publicClient = usePublicClient();

const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http('https://api.pimlico.io/v2/11155111/rpc?apikey=<YOUR-API-KEY>'),
  paymaster: true, // The same Pimlico URL will be used for bundler and paymaster.
});
3. Create a smart account
Create an account to create and redeem an invitation. This account will create a delegation, and must be a MetaMask smart account. This example uses a Hybrid smart account, which is a flexible smart account implementation that supports both an externally owned account (EOA) owner and any number of passkey (WebAuthn) signers:

import { Implementation, toMetaMaskSmartAccount } from '@metamask/delegation-toolkit';
import { useAccount, usePublicClient, useWalletClient } from 'wagmi';

const { address } = useAccount();
const publicClient = usePublicClient();
const { data: walletClient } = useWalletClient();

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [address, [], [], []],
  deploySalt: '0x',
  signer: { walletClient },
});
4. Create an invitation
4.1. Deploy the account
To create an invitation, first deploy the smart account by sending a user operation:

import { zeroAddress } from 'viem';

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [{ to: zeroAddress }],
  maxFeePerGas,
  maxPriorityFeePerGas,
});
4.2. Fund the account
Fund the deployed smart account with some Sepolia ETH to enable the invitee to spend funds when they redeem the invitation.

note
You can use the MetaMask faucet to get Sepolia ETH.

4.3. Create an open root delegation
Create an open root delegation to represent an invitation. A root delegation is the first delegation in a chain of delegations, and an open root delegation grants permission to any account. In this example, the inviter creates an invitation that can be redeemed by any invitee, allowing the invitee to spend up to 0.001 ETH.

import { createOpenDelegation } from '@metamask/delegation-toolkit';

const delegation = createOpenDelegation({
  from: smartAccount.address,
  environment: smartAccount.environment;
  scope: {
    type: 'nativeTokenTransferAmount',
    // 0.001 ETH in wei format.
    maxAmount: 1000000000000000n,
  },
});
4.4. Sign the delegation
Sign the delegation to enable the invitee to redeem the invitation in the future:

const signature = await smartAccount.signDelegation({
  delegation,
})

const signedDelegation = {
  ...delegation,
  signature,
}
4.5. Share the invitation
Encode the delegation into a shareable invite link:

import { Delegation } from '@metamask/delegation-toolkit';

export function encodeDelegation(delegation: Delegation): string {
  const delegationJson = JSON.stringify(delegation);
  return Buffer.from(delegationJson, 'utf-8').toString('base64');
}

const encoded = encodeDelegation(signedDelegation);

const url = new URL(window.location.href);
url.searchParams.set('delegation', encoded);
const shareableUrl = url.toString();
The inviter can now share the link with anyone.

5. Redeem the invitation
5.1. Decode the shared invitation
When the invitee opens the shared invite link, decode the delegation:

import { Delegation } from '@metamask/delegation-toolkit';

const urlParams = new URLSearchParams(window.location.search);
const encodedDelegation = urlParams.get('delegation');

export function decodeDelegation(encodedDelegation: string): Delegation {
  const decodedDelegationJson = Buffer.from(encodedDelegation, 'base64').toString('utf-8');
  return JSON.parse(decodedDelegationJson) as Delegation;
}

const decodedDelegation = decodeDelegation(encodedDelegation);
5.2. Redeem the delegation
Redeem the delegation by submitting a user operation from the smart account to the DelegationManager contract. Submitting the user operation deploys the account for first-time users.

The delegation manager validates the delegation and executes delegated actions. In this case, the invitee can spend up to 0.001 ETH when using your dapp.

import { createExecution, getDeleGatorEnvironment, ExecutionMode } from '@metamask/delegation-toolkit';
import { DelegationManager } from '@metamask/delegation-toolkit/contracts';

const delegations = [decodedDelegation];

const executions = createExecution(smartAccount.address, 1000000000000000n);

const redeemDelegationCalldata = DelegationManager.encode.redeemDelegations({
  delegations: [delegations],
  modes: [ExecutionMode.SingleDefault],
  executions: [executions]
});

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: smartAccount.address,
      data: redeemDelegationCalldata,
    },
  ],
  maxFeePerGas,
  maxPriorityFeePerGas,
});
Next steps
See invitation-link-example on GitHub for a complete example dapp.
When creating an invitation, you can add more rules and restrictions using delegation scopes and caveat enforcers.
Learn more about smart account implementations.
Learn more about delegation types.
MetaMask Smart Accounts API reference
The following API methods are related to creating, managing, and signing with MetaMask Smart Accounts.

aggregateSignature
Aggregates multiple partial signatures into a single combined multisig signature.

Parameters
Name	Type	Required	Description
signatures	PartialSignature[]	Yes	Collection of partial signatures provided by signers, to be merged into an aggregated signature.
Example
example.ts
config.ts
import { 
  bundlerClient, 
  aliceSmartAccount, 
  bobSmartAccount,
  aliceAccount,
  bobAccount,
} from "./config.ts";
import { aggregateSignature } from "@metamask/delegation-toolkit";

const userOperation = await bundlerClient.prepareUserOperation({
  account: aliceSmartAccount,
  calls: [
    {
      target: zeroAddress,
      value: 0n,
      data: "0x",
    }
  ]
});

const aliceSignature = await aliceSmartAccount.signUserOperation(userOperation);
const bobSignature = await bobSmartAccount.signUserOperation(userOperation);

const aggregatedSignature = aggregateSignature({
  signatures: [{
    signer: aliceAccount.address,
    signature: aliceSignature,
    type: "ECDSA",
  }, {
    signer: bobAccount.address,
    signature: bobSignature,
    type: "ECDSA",
  }],
});
encodeCalls
Encodes calls for execution by a MetaMask smart account. If there's a single call directly to the smart account, it returns the call data directly. For multiple calls or calls to other addresses, it creates executions and encodes them for the smart account's execute function.

The execution mode is set to SingleDefault for a single call to other address, or BatchDefault for multiple calls.

Parameters
Name	Type	Required	Description
calls	Call[]	Yes	List of calls to be encoded.
Example
example.ts
config.ts
import { smartAccount } from "./config.ts";

const calls = [{
  to: zeroAddress,
  data: "0x",
  value: 0n
}];

const executeCallData = await smartAccount.encodeCalls(calls);
getFactoryArgs
Returns the factory address and factory data that can be used to deploy a smart account.

Example
example.ts
config.ts
import { smartAccount } from "./config.ts";

const { factory, factoryData } = await smartAccount.getFactoryArgs();
getNonce
Returns the nonce for a smart account.

Example
example.ts
config.ts
import { smartAccount } from "./config.ts";

const nonce = await smartAccount.getNonce();
signDelegation
Signs the delegation and returns the delegation signature.

Parameters
Name	Type	Required	Description
delegation	Omit<Delegation, "signature">	Yes	The unsigned delegation object to sign.
chainId	number	No	The chain ID on which the Delegation Manager is deployed.
Example
example.ts
config.ts
import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { delegatorSmartAccount } from "./config.ts";

// The address to which the delegation is granted. It can be an EOA address, or 
// smart account address.
const delegate = "0x2FcB88EC2359fA635566E66415D31dD381CF5585";

const delegation = createDelegation({
  to: delegate,
  from: account.address,
  environment: delegatorSmartAccount.environment,
  scope: {
    type: "nativeTokenTransferAmount",
    // 0.001 ETH in wei format.
    maxAmount: 1000000000000000n,
  },
});

const signature = delegatorSmartAccount.signDelegation({ delegation });
signMessage
Generates the EIP-191 signature using the MetaMaskSmartAccount signer. The Delegation Toolkit uses Viem under the hood to provide this functionality.

Parameters
See the Viem signMessage parameters.

Example
example.ts
config.ts
import { smartAccount } from "./config.ts";

const signature = smartAccount.signMessage({
  message: 'hello world', 
})
signTypedData
Generates the EIP-712 signature using the MetaMaskSmartAccount signer. The Delegation Toolkit uses Viem under the hood to provide this functionality.

Parameters
See the Viem signTypedData parameters.

Example
example.ts
config.ts
import { smartAccount } from "./config.ts";

const signature = smartAccount.signTypedData({ 
  domain, 
  types, 
  primaryType: "Mail",
  message: { 
    from: { 
      name: "Cow",
      wallet: "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
    }, 
    to: { 
      name: "Bob",
      wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB",
    }, 
    contents: "Hello, Bob!",
  }, 
}) 
signUserOperation
Signs a user operation with the MetaMaskSmartAccount signer. The Delegation Toolkit uses Viem under the hood to provide this functionality.

Parameters
See the Viem signUserOperation parameters.

Example
example.ts
config.ts
import { smartAccount } from "./config.ts";

const userOpSignature = smartAccount.signUserOperation({ 
  callData: "0xdeadbeef",
  callGasLimit: 141653n,
  maxFeePerGas: 15000000000n,
  maxPriorityFeePerGas: 2000000000n,
  nonce: 0n,
  preVerificationGas: 53438n,
  sender: "0xE911628bF8428C23f179a07b081325cAe376DE1f",
  verificationGasLimit: 259350n,
  signature: "0x",
 });
toMetaMaskSmartAccount
Creates a MetaMaskSmartAccount instance.

Parameters
Name	Type	Required	Description
client	Client	Yes	Viem Client to retrieve smart account data.
implementation	TImplementation	Yes	Implementation type for the smart account. Can be Hybrid, Multisig, or Stateless7702.
signer	SignerConfigByImplementation <TImplementation>	Yes	Signers for the smart account. Can be a Viem Account, Viem Wallet Client, or a WebAuthnAccount. Web3AuthnAccounts are only supported for Hybrid implementations.
environment	DeleGatorEnvironment	No	Environment to resolve the smart contracts.
deployParams	DeployParams<TImplementation>	Required if address is not provided	The parameters that will be used to deploy the smart account and generate its deterministic address.
deploySalt	Hex	Required if address is not provided	The salt that will be used to deploy the smart account.
address	Address	Required if deployParams and deploySalt are not provided, or if the implementation is Stateless7702.	The address of the smart account. If an address is provided, the smart account will not be deployed. This should be used if you intend to interact with an existing smart account.
Hybrid implementation
deployParams
All Hybrid deploy parameters are required:

Name	Type	Description
owner	Hex	The owner's account address. The owner can be the zero address, indicating that there is no owner configured.
p256KeyIds	Hex[]	An array of key identifiers for passkey signers.
p256XValues	bigint[]	An array of public key x-values for passkey signers.
p256YValues	bigint[]	An array of public key y-values for passkey signers.
Example
example.ts
config.ts
import {
  Implementation,
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";
import { publicClient, account } from "./config.ts";

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: "0x",
  signer: { account: account },
});
Multisig implementation
deployParams
All Multisig deploy parameters are required:

Name	Type	Description
signers	Hex[]	An array of EOA signer addresses.
threshold	bigint	The number of signers required to execute a transaction.
Example
example.ts
config.ts
import { 
  publicClient, 
  aliceAccount, 
  bobAccount 
} from "./config.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const signers = [ aliceAccount.address, bobAccount.address ];
const threshold = 2n

const aliceSmartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.MultiSig,
  deployParams: [signers, threshold],
  deploySalt: "0x",
  signer: [ { account: aliceAccount } ],
});
Stateless7702 implementation example
example.ts
config.ts
import {
  Implementation,
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";
import { publicClient, account } from "./config.ts";

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Stateless7702,
  address: account.address,
  signer: { account },
});
Delegation API reference
The following API methods are related to creating and managing delegations.

createCaveatBuilder
Builds an array of caveats.

Parameters
Name	Type	Required	Description
environment	DeleGatorEnvironment	Yes	Environment to resolve the smart contracts for the current chain.
config	CaveatBuilderConfig	No	Configuration for CaveatBuilder.
Example
example.ts
config.ts
import { createCaveatBuilder } from "@metamask/delegation-toolkit";
import { delegatorSmartAccount } from "./config.ts";

const caveats = createCaveatBuilder(delegatorSmartAccount.environment)
Allow empty caveats
To create an empty caveat collection, set the CaveatBuilderConfig.allowEmptyCaveats to true.

example.ts
import { createCaveatBuilder } from "@metamask/delegation-toolkit";
// The config.ts is the same as in the previous example.
import { delegatorSmartAccount } from "./config.ts";

const caveats = createCaveatBuilder(delegatorSmartAccount.environment, {
  allowEmptyCaveats: true,
});
createDelegation
Creates a delegation with a specific delegate.

Parameters
Name	Type	Required	Description
from	Hex	Yes	The address that is granting the delegation.
to	Hex	Yes	The address to which the delegation is being granted.
scope	ScopeConfig	Yes	The scope of the delegation that defines the initial authority.
environment	DeleGatorEnvironment	Yes	The environment used by the toolkit to define contract addresses for interacting with the Delegation Framework contracts.
caveats	Caveats	No	Caveats that further refine the authority granted by the scope.
parentDelegation	Delegation | Hex	No	The parent delegation or its corresponding hex to create a delegation chain.
salt	Hex	No	The salt for generating the delegation hash. This helps prevent hash collisions when creating identical delegations.
Example
import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const delegation = createDelegation({
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Address to which the delegation is being granted
  to: "0x2B2dBd1D5fbeB77C4613B66e9F35dBfE12cB0488",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
  scope: {
    type: "nativeTokenTransferAmount",
    // 0.001 ETH in wei format.
    maxAmount: 1000000000000000n,
  },
});
createOpenDelegation
Creates an open delegation that can be redeemed by any delegate.

Parameters
Name	Type	Required	Description
from	Hex	Yes	The address that is granting the delegation.
scope	ScopeConfig	Yes	The scope of the delegation that defines the initial authority.
environment	DeleGatorEnvironment	Yes	The environment used by the toolkit to define contract addresses for interacting with the Delegation Framework contracts.
caveats	Caveats	No	Caveats that further refine the authority granted by the scope.
parentDelegation	Delegation | Hex	No	The parent delegation or its corresponding hex to create a delegation chain.
salt	Hex	No	The salt for generating the delegation hash. This helps prevent hash collisions when creating identical delegations.
Example
import { createOpenDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const delegation = createOpenDelegation({
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
  scope: {
    type: "nativeTokenTransferAmount",
    // 0.001 ETH in wei format.
    maxAmount: 1000000000000000n,
  },
});
createExecution
Creates an ExecutionStruct instance.

Parameters
Name	Type	Required	Description
target	Address	No	Address of the contract or recipient that the call is directed to.
value	bigint	No	Value of native tokens to send along with the call in wei.
callData	Hex	No	Encoded function data or payload to be executed on the target address.
Example
import { createExecution } from "@metamask/delegation-toolkit";

// Creates an ExecutionStruct to transfer 0.01 ETH to
// 0xe3C818389583fDD5cAC32f548140fE26BcEaE907 address.
const execution = createExecution({
  target: "0xe3C818389583fDD5cAC32f548140fE26BcEaE907",
  // 0.01 ETH in wei
  value: 10000000000000000n,
  callData: "0x",
});
deployDeleGatorEnvironment
Deploys the Delegation Framework contracts to an EVM chain.

Parameters
Name	Type	Required	Description
walletClient	WalletClient	Yes	Viem Wallet Client to deploy the contracts.
publicClient	PublicClient	Yes	Viem Public Client to interact with the given chain.
chain	Chain	Yes	Viem Chain where you wish to deploy the Delegation Framework contracts.
deployedContracts	{ [contract: string]: Hex }	No	Allows overriding specific contract addresses when calling the function. For example, if certain contracts have already been deployed on the target chain, their addresses can be provided directly to the function.
Example
example.ts
config.ts
import { deployDeleGatorEnvironment } from "@metamask/delegation-toolkit/utils";
import { walletClient, publicClient } from "./config.ts";
import { sepolia as chain } from "viem/chains";

const environment = await deployDeleGatorEnvironment(
  walletClient, 
  publicClient, 
  chain
);
Inject deployed contracts
Once the contracts are deployed, you can use them to override the delegator environment using overrideDeployedEnvironment.

example.ts
import { walletClient, publicClient } from "./config.ts";
import { sepolia as chain } from "viem/chains";
import { DeleGatorEnvironment } from "@metamask/delegation-toolkit";
import { 
  overrideDeployedEnvironment,
  deployDeleGatorEnvironment,
} from "@metamask/delegation-toolkit/utils";

const environment: DeleGatorEnvironment = await deployDeleGatorEnvironment(
  walletClient, 
  publicClient, 
  chain
);

overrideDeployedEnvironment(
  chain.id,
  "1.3.0",
  environment,
);
disableDelegation
Encodes the calldata for disabling a delegation.

Parameters
Name	Type	Required	Description
delegation	Delegation	Yes	The delegation to be disabled.
Example
example.ts
delegation.ts
import { DelegationManager } from "@metamask/delegation-toolkit/contracts";
import { delegation } from "./delegation.ts";

const disableDelegationData = DelegationManager.encode.disableDelegation({
  delegation,
});
getDeleGatorEnvironment
Resolves the DeleGatorEnvironment for a chain.

Parameters
Name	Type	Required	Description
chainId	number	Yes	The chain ID of the network for which the DeleGatorEnvironment should be resolved.
version	SupportedVersion	No	Specifies the version of the Delegation Framework contracts to use. If omitted, the latest supported version will be used by default.
Example
import { getDeleGatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const environment = getDeleGatorEnvironment(sepolia.id)
overrideDeployedEnvironment
Overrides or adds the DeleGatorEnvironment for a chain and supported version.

Parameters
Name	Type	Required	Description
chainId	number	Yes	The chain ID of the network for which the DeleGatorEnvironment should be overridden.
version	SupportedVersion	Yes	The version of the Delegation Framework contracts to override for the specified chain.
environment	DeleGatorEnvironment	Yes	The environment containing contract addresses to override for the given chain and version.
Example
example.ts
environment.ts
import { environment } from "./environment.ts";
import { overrideDeployedEnvironment } from "@metamask/delegation-toolkit/utils";
import { sepolia } from "viem/chains";

overrideDeployedEnvironment(
  sepolia.id,
  "1.3.0",
  environment
);
redeemDelegations
Encodes calldata for redeeming delegations. This method supports batch redemption, allowing multiple delegations to be processed within a single transaction.

Parameters
Name	Type	Required	Description
delegations	Delegation[][]	Yes	A nested collection representing chains of delegations. Each inner collection contains a chain of delegations to be redeemed.
modes	ExecutionMode[]	Yes	A collection specifying the execution mode for each corresponding delegation chain. Supported execution modes are SingleDefault, SingleTry, BatchDefault, and BatchTry.
executions	ExecutionStruct[][]	Yes	A nested collection where each inner collection contains a list of ExecutionStruct objects associated with a specific delegation chain.
Example
This example assumes you have a delegation signed by the delegator.

import { createExecution, ExecutionMode } from "@metamask/delegation-toolkit";
import { DelegationManager } from "@metamask/delegation-toolkit/contracts";
import { zeroAddress } from "viem";

const data = DelegationManager.encode.redeemDelegations({
  delegations: [[ signedDelegation ]],
  modes: [ ExecutionMode.SingleDefault ],
  executions: [[ execution ]],
});
signDelegation
Signs the delegation and returns the delegation signature.

Parameters
Name	Type	Required	Description
signer	WalletClient	Yes	Viem Wallet Client to sign the delegation.
delegation	Omit<Delegation, "signature">	Yes	The unsigned delegation object to sign.
chainId	number	Yes	The chain ID on which the delegation manager is deployed.
delegationManager	0x${string}	Yes	The address of the Delegation Manager.
name	string	No	The name of the domain of the Delegation Manager. The default is DelegationManager.
version	string	No	The version of the domain of the Delegation Manager. The default is 1.
Example
example.ts
config.ts
import { signDelegation } from "@metamask/delegation-toolkit";
import { walletClient, delegation, delegationManager } from "./config.ts";
import { sepolia } from "viem/chains";

const signature = signDelegation({
  signer: walletClient,
  delegation,
  chainId: sepolia.id,
  delegationManager,
})
Delegation scopes
When creating a delegation, you can configure the following scopes to define the delegation's initial authority. Learn how to use delegation scopes.

Spending limit scopes
ERC-20 periodic scope
Ensures a per-period limit for ERC-20 token transfers. At the start of each new period, the allowance resets.

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-20 token contract address as a hex string.
periodAmount	bigint	Yes	The maximum amount of tokens that can be transferred per period.
periodDuration	number	Yes	The duration of each period in seconds.
startDate	number	Yes	The timestamp when the first period begins in seconds.
Example
import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const delegation = createDelegation({
  scope: {
    type: "erc20PeriodTransfer",
    tokenAddress: "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
    periodAmount: 1000000000000000000n,
    periodDuration: 86400,
    startDate: 1743763600,
  },
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Address to which the delegation is being granted
  to: "0x2B2dBd1D5fbeB77C4613B66e9F35dBfE12cB0488",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
});
ERC-20 streaming scope
Ensures a linear streaming transfer limit for ERC-20 tokens. Token transfers are blocked until the defined start timestamp. At the start, a specified initial amount is released, after which tokens accrue linearly at the configured rate, up to the maximum allowed amount.

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-20 token contract address.
initialAmount	bigint	Yes	The initial amount that can be transferred at start time.
maxAmount	bigint	Yes	The maximum total amount that can be unlocked.
amountPerSecond	bigint	Yes	The rate at which tokens accrue per second.
startTime	number	Yes	The start timestamp in seconds.
Example
import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const delegation = createDelegation({
  scope: {
    type: "erc20Streaming",
    tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
    amountPerSecond: 100n,
    initialAmount: 1000000n,
    maxAmount: 10000000n,
    startTime: 1703980800,
  },
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Address to which the delegation is being granted
  to: "0x2B2dBd1D5fbeB77C4613B66e9F35dBfE12cB0488",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
});
ERC-20 transfer scope
Ensures that ERC-20 token transfers are limited to a predefined maximum amount. This scope is useful for setting simple, fixed transfer limits without any time-based or streaming conditions.

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-20 token contract address.
maxAmount	bigint	Yes	The maximum amount of tokens that can be transferred by delegate.
Example
import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const delegation = createDelegation({
  scope: {
    type: "erc20TransferAmount",
    tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
    maxAmount: 10000n,
  },
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Address to which the delegation is being granted
  to: "0x2B2dBd1D5fbeB77C4613B66e9F35dBfE12cB0488",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
});
ERC-721 scope
Limits the delegation to ERC-721 token (NFT) transfers only.

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-721 token contract address.
tokenId	bigint	Yes	The ID of the ERC-721 token that can be transferred by delegate.
Example
import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const delegation = createDelegation({
  scope: {
    type: "erc721Transfer",
    tokenAddress: "0x3fF528De37cd95b67845C1c55303e7685c72F319",
    tokenId: 1n,
  },
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Address to which the delegation is being granted
  to: "0x2B2dBd1D5fbeB77C4613B66e9F35dBfE12cB0488",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
});
Native token periodic scope
Ensures a per-period limit for native token transfers. At the start of each new period, the allowance resets.

Parameters
Name	Type	Required	Description
periodAmount	bigint	Yes	The maximum amount of tokens that can be transferred per period.
periodDuration	number	Yes	The duration of each period in seconds.
startDate	number	Yes	The timestamp when the first period begins in seconds.
allowedCalldata	AllowedCalldataBuilderConfig[]	No	The list of calldata that the delegate is allowed to call. Cannot be used together with exactCalldata.
exactCalldata	ExactCalldataBuilderConfig	No	The calldata that the delegate is allowed to call. By default, the value is set to 0x. Cannot be used together with allowedCalldata.
Example
import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const delegation = createDelegation({
  scope: {
    type: "nativeTokenPeriodTransfer",
    periodAmount: 1000000000000000000n,
    periodDuration: 86400,
    startDate: 1743763600,
  },
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Address to which the delegation is being granted
  to: "0x2B2dBd1D5fbeB77C4613B66e9F35dBfE12cB0488",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
});
Native token streaming scope
Ensures a linear streaming transfer limit for native tokens. Token transfers are blocked until the defined start timestamp. At the start, a specified initial amount is released, after which tokens accrue linearly at the configured rate, up to the maximum allowed amount.

Parameters
Name	Type	Required	Description
initialAmount	bigint	Yes	The initial amount that can be transferred at start time.
maxAmount	bigint	Yes	The maximum total amount that can be unlocked.
amountPerSecond	bigint	Yes	The rate at which tokens accrue per second.
startTime	number	Yes	The start timestamp in seconds.
allowedCalldata	AllowedCalldataBuilderConfig[]	No	The list of calldata that the delegate is allowed to call. Cannot be used together with exactCalldata.
exactCalldata	ExactCalldataBuilderConfig	No	The calldata that the delegate is allowed to call. By default, the value is set to 0x. Cannot be used together with allowedCalldata.
Example
import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const delegation = createDelegation({
  scope: {
    type: "nativeTokenStreaming",
    amountPerSecond: 100n,
    initialAmount: 1000000n,
    maxAmount: 10000000n,
    startTime: 1703980800,
  },
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Address to which the delegation is being granted
  to: "0x2B2dBd1D5fbeB77C4613B66e9F35dBfE12cB0488",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
});
Native token transfer scope
Ensures that native token transfers are limited to a predefined maximum amount. This scope is useful for setting simple, fixed transfer limits without any time based or streaming conditions.

Parameters
Name	Type	Required	Description
maxAmount	bigint	Yes	The maximum amount of tokens that can be transferred by delegate.
allowedCalldata	AllowedCalldataBuilderConfig[]	No	The list of calldata that the delegate is allowed to call. Cannot be used together with exactCalldata.
exactCalldata	ExactCalldataBuilderConfig	No	The calldata that the delegate is allowed to call. By default, the value is set to 0x. Cannot be used together with allowedCalldata.
Example
import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const delegation = createDelegation({
  scope: {
    type: "nativeTokenTransferAmount",
    // 0.001 ETH in wei format.
    maxAmount: 1000000000000000n,
  },
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Address to which the delegation is being granted
  to: "0x2B2dBd1D5fbeB77C4613B66e9F35dBfE12cB0488",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
});
Function call scope
Defines the specific methods, contract addresses, and calldata that are allowed for the delegation.

Parameters
Name	Type	Required	Description
targets	Address[]	Yes	The list of addresses that the delegate is allowed to call.
selectors	MethodSelector[]	Yes	The list of method selectors that the delegate is allowed to call. The selector value can be 4-byte hex string, ABI function signature, or ABI function object.
allowedCalldata	AllowedCalldataBuilderConfig[]	No	The list of calldata that the delegate is allowed to call. Cannot be used together with exactCalldata.
exactCalldata	ExactCalldataBuilderConfig	No	The calldata that the delegate is allowed to call. Cannot be used together with allowedCalldata.
Example
This example sets the delegation scope to allow the delegate to call the approve function on the USDC token contract.

import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const delegation = createDelegation({
  scope: {
    type: "functionCall",
    targets: ["0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238"], // USDC address on Sepolia.
    selectors: ["approve(address, uint256)"]
  },
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Address to which the delegation is being granted
  to: "0x2B2dBd1D5fbeB77C4613B66e9F35dBfE12cB0488",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
});
Ownership transfer scope
Restricts a delegation to ownership transfer calls only.

Parameters
Name	Type	Required	Description
contractAddress	Address	Yes	The target contract address for which ownership transfers are allowed.
Example
import { createDelegation, getDelegatorEnvironment } from "@metamask/delegation-toolkit";
import { sepolia } from "viem/chains";

const contractAddress = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238"

const delegation = createDelegation({
  scope: {
    type: "ownershipTransfer",
    contractAddress,
  },
  // Address that is granting the delegation
  from: "0x7E48cA6b7fe6F3d57fdd0448B03b839958416fC1",
  // Address to which the delegation is being granted
  to: "0x2B2dBd1D5fbeB77C4613B66e9F35dBfE12cB0488",
  // Alternatively you can use environment property of MetaMask smart account.
  environment: getDelegatorEnvironment(sepolia.id);
});
Caveats
When constraining a delegation scope, you can specify the following caveat types.

allowedCalldata
Limits the calldata that is executed.

You can use this caveat to enforce function parameters. We strongly recommend using this caveat to validate static types and not dynamic types. You can validate dynamic types through a series of allowedCalldata terms, but this is tedious and error-prone.

Caveat enforcer contract: AllowedCalldataEnforcer.sol

Parameters
Name	Type	Required	Description
startIndex	number	Yes	The index in the calldata byte array (including the 4-byte method selector) where the expected calldata starts.
value	Hex	Yes	The expected calldata that must match at the specified index.
Example
const value = encodeAbiParameters(
  [
    { type: "string" },
    { type: "uint256" }
  ], 
  [
    "Hello Gator",
    12345n
  ]
);

const caveats = [{
  type: "allowedCalldata",
  startIndex: 4,
  value,
}];
note
This example uses Viem's encodeAbiParameters utility to encode the parameters as ABI-encoded hex strings.

allowedMethods
Limits what methods the delegate can call.

Caveat enforcer contract: AllowedMethodsEnforcer.sol

Parameters
Name	Type	Required	Description
selectors	MethodSelector[]	Yes	The list of method selectors that the delegate is allowed to call. The selector value can be 4-byte hex string, ABI function signature, or ABI function object.
Example
const caveats = [{
  type: "allowedMethods",
  selectors: [
    // 4-byte Hex string.
    "0xa9059cbb",
    // ABI function signature.
    "transfer(address,uint256)",
    // ABI function object.
    {
      name: 'transfer',
      type: 'function',
      inputs: [
        { name: 'recipient', type: 'address' },
        { name: 'amount', type: 'uint256' }
      ],
      outputs: [],
      stateMutability: 'nonpayable',
    },
  ]
}];
note
This example adds the transfer function to the allowed methods in three different ways - as the 4-byte function selector, the ABI function signature, and the ABIFunction object.

allowedTargets
Limits what addresses the delegate can call.

Caveat enforcer contract: AllowedTargetsEnforcer.sol

Parameters
Name	Type	Required	Description
targets	Address[]	Yes	The list of addresses that the delegate is allowed to call.
Example
const caveats = [{
  type: "allowedTargets",
  targets: [
    "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
    "0xB2880E3862f1024cAC05E66095148C0a9251718b",
  ]
}];
argsEqualityCheck
Ensures that the args provided when redeeming the delegation are equal to the terms specified on the caveat.

Caveat enforcer contract: ArgsEqualityCheckEnforcer.sol

Parameters
Name	Type	Required	Description
args	Hex	Yes	The expected args that must match exactly when redeeming the delegation.
Example
const caveats = [{
  type: "argsEqualityCheck",
  args: "0xf2bef872456302645b7c0bb59dcd96ffe6d4a844f311ebf95e7cf439c9393de2",
}];
blockNumber
Specifies a range of blocks through which the delegation will be valid.

Caveat enforcer contract: BlockNumberEnforcer.sol

Parameters
Name	Type	Required	Description
afterThreshold	bigint	Yes	The block number after which the delegation is valid. Set the value to 0n to disable this threshold.
beforeThreshold	bigint	Yes	The block number before which the delegation is valid. Set the value to 0n to disable this threshold.
Example
const caveats = [{
  type: "blockNumber",
  afterThreshold: 19426587n,
  beforeThreshold: 0n,
}];
deployed
Ensures a contract is deployed, and if not, deploys the contract.

Caveat enforcer contract: DeployedEnforcer.sol

Parameters
Name	Type	Required	Description
contractAddress	Address	Yes	The contract address.
salt	Hex	Yes	The salt to use with the deployment.
bytecode	Hex	Yes	The bytecode of the contract.
Example
const caveats = [{
  type: "deployed",
  contractAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
  salt: "0x0e3e8e2381fde0e8515ed47ec9caec8ba2bc12603bc2b36133fa3e3fa4d88587",
  bytecode: "0x..." // The deploy bytecode for the contract at 0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92
}];
erc1155BalanceChange
Ensures that the recipient's ERC-1155 token balance has changed within the allowed bounds — either increased by a minimum or decreased by a maximum specified amount.

Caveat enforcer contract: ERC1155BalanceBalanceEnforcer.sol

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-1155 token contract address.
recipient	Address	Yes	The address on which the checks will be applied.
tokenId	bigint	Yes	The ID of the ERC-1155 token.
balance	bigint	Yes	The amount by which the balance must be changed.
changeType	BalanceChangeType	Yes	The balance change type for the ERC-1155 token. Specifies whether the balance should have increased or decreased. Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.
Example
const caveats = [{
  type: "erc1155BalanceChange",
  tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
  recipient: "0x3fF528De37cd95b67845C1c55303e7685c72F319",
  tokenId: 1n,
  balance: 1000000n,
  changeType: BalanceChangeType.Increase,
}];
erc20BalanceChange
Ensures that the recipient's ERC-20 token balance has changed within the allowed bounds — either increased by a minimum or decreased by a maximum specified amount.

Caveat enforcer contract: ERC20BalanceChangeEnforcer.sol

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-20 token contract addres.
recipient	Address	Yes	The address on which the checks will be applied.
balance	bigint	Yes	The amount by which the balance must be changed.
changeType	BalanceChangeType	Yes	The balance change type for the ERC-20 token. Specifies whether the balance should have increased or decreased. Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.
Example
const caveats = [{
  type: "erc20BalanceChange",
  tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
  recipient: "0x3fF528De37cd95b67845C1c55303e7685c72F319",
  balance: 1000000n,
  changeType: BalanceChangeType.Increase,
}];
erc20PeriodTransfer
Ensures that ERC-20 token transfers remain within a predefined limit during a specified time window. At the start of each new period, the allowed transfer amount resets. Any unused transfer allowance from the previous period does not carry over and is forfeited.

Caveat enforcer contract: ERC20PeriodTransferEnforcer.sol

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-20 token contract address as a hex string.
periodAmount	bigint	Yes	The maximum amount of tokens that can be transferred per period.
periodDuration	number	Yes	The duration of each period in seconds.
startDate	number	Yes	The timestamp when the first period begins in seconds.
Example
// Current time as start date. 
// Since startDate is in seconds, we need to convert milliseconds to seconds.
const startDate = Math.floor(Date.now() / 1000);

const caveats = [{
  type: "erc20PeriodTransfer",
  // Address of the ERC-20 token.
  tokenAddress: "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
  // 1 ERC-20 token - 18 decimals, in wei.
  periodAmount: 1000000000000000000n,
  // 1 day in seconds.
  periodDuration: 86400,
  startDate,
}];
erc20Streaming
Enforces a linear streaming transfer limit for ERC-20 tokens. Block token access until the specified start timestamp. At the start timestamp, immediately release the specified initial amount. Afterward, accrue tokens linearly at the specified rate, up to the specified maximum.

Caveat enforcer contract: ERC20StreamingEnforcer.sol

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-20 token contract address.
initialAmount	bigint	Yes	The initial amount that can be transferred at start time.
maxAmount	bigint	Yes	The maximum total amount that can be unlocked.
amountPerSecond	bigint	Yes	The rate at which tokens accrue per second.
startTime	number	Yes	The start timestamp in seconds.
Example
// Current time as start date. 
// Since startDate is in seconds, we need to convert milliseconds to seconds.
const startDate = Math.floor(Date.now() / 1000);

const caveats = [{
  type: "erc20Streaming",
  // Address of the ERC-20 token.
  tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
  // 1 ERC-20 token - 18 decimals, in wei.
  initialAmount: 1000000000000000000n,
  // 10 ERC-20 token - 18 decimals, in wei.
  maxAmount: 10000000000000000000n
  // 0.00001 ERC-20 token - 18 decimals, in wei.
  amountPerSecond: 10000000000000n,
  startDate,
}];
erc20TransferAmount
Limits the transfer of ERC-20 tokens.

Caveat enforcer contract: ERC20TransferAmountEnforcer.sol

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-20 token contract address.
maxAmount	bigint	Yes	The maximum amount of tokens that can be transferred by delegate.
Example
const caveats = [{
  type: "erc20TransferAmount",
  tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
  // 1 ERC-20 token - 18 decimals, in wei.
  maxAmount: 1000000000000000000n
}];
erc721BalanceChange
Ensures that the recipient's ERC-721 token balance has changed within the allowed bounds — either increased by a minimum or decreased by a maximum specified amount.

Caveat enforcer contract: ERC721BalanceChangeEnforcer.sol

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-721 token contract addres.
recipient	Address	Yes	The address on which the checks will be applied.
balance	bigint	Yes	The amount by which the balance must be changed.
changeType	BalanceChangeType	Yes	The balance change type for the ERC-721 token. Specifies whether the balance should have increased or decreased. Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.
Example
const caveats = [{
  type: "erc721BalanceChange",
  tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
  recipient: "0x3fF528De37cd95b67845C1c55303e7685c72F319",
  balance: 1000000n,
  changeType: BalanceChangeType.Increase,
}];
erc721Transfer
Restricts the execution to only allow ERC-721 token transfers, specifically the transferFrom(from, to, tokenId) function, for a specified token ID and contract.

Caveat enforcer contract: ERC721TransferEnforcer.sol

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-721 token contract address.
tokenId	bigint	Yes	The ID of the ERC-721 token that can be transferred by delegate.
Example
const caveats = [{
  type: "erc721Transfer",
  tokenAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92",
  tokenId: 1n
}];
exactCalldata
Verifies that the transaction calldata matches the expected calldata. For batch transactions, see exactCalldataBatch.

Caveat enforcer contract: ExactCalldataEnforcer.sol

Parameters
Name	Type	Required	Description
calldata	Hex	Yes	The calldata that the delegate is allowed to call.
Example
const caveats = [{
  type: "exactCalldata",
  calldata: "0x1234567890abcdef",
}];
exactCalldataBatch
Verifies that the provided batch execution calldata matches the expected calldata for each individual execution in the batch.

Caveat enforcer contract: ExactCalldataBatchEnforcer.sol

Parameters
Name	Type	Required	Description
executions	ExecutionStruct[]	Yes	The list of executions that must be matched exactly in the batch. Each execution specifies a target address, value, and calldata.
Example
const executions = [
  {
    target: "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
    value: 1000000000000000000n, // 1 ETH
    callData: "0x",
  },
  {
    target: "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
    value: 0n,
    callData: "0x",
  },
];

const caveats = [{
  type: "exactCalldataBatch",
  executions,
}];
exactExecution
Verifies that the provided execution matches the expected execution. For batch transactions, see exactExecutionBatch.

Caveat enforcer contract: ExactExecutionEnforcer.sol

Parameters
Name	Type	Required	Description
execution	ExecutionStruct	Yes	The execution that must be matched exactly. Specifies the target address, value, and calldata.
Example
const caveats = [{
  type: "exactExecution",
  target: "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
  value: 1000000000000000000n,
  callData: "0x",
}];
exactExecutionBatch
Verifies that each execution in the batch matches the expected execution parameters - including target, value, and calldata.

Caveat enforcer contract: ExactExecutionBatchEnforcer.sol

Parameters
Name	Type	Required	Description
executions	ExecutionStruct[]	Yes	The list of executions that must be matched exactly in the batch. Each execution specifies a target address, value, and calldata.
Example
const executions = [
  {
    target: "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
    value: 1000000000000000000n, // 1 ETH
    callData: "0x",
  },
  {
    target: "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
    value: 0n,
    callData: "0x",
  },
];

const caveats = [{
  type: "exactExecutionBatch",
  executions,
}];
id
Specifies an ID for multiple delegations. Once one of them is redeemed, the other delegations with the same ID are revoked.

Caveat enforcer contract: IdEnforcer.sol

Parameters
Name	Type	Required	Description
id	bigint	number	Yes
Example
const caveats = [{
  type: "id",
  id: 123456,
}];
limitedCalls
Limits the number of times the delegate can perform executions on the delegator's behalf.

Caveat enforcer contract: LimitedCallsEnforcer.sol

Parameters
Name	Type	Required	Description
limit	number	Yes	The maximum number of times this delegation may be redeemed.
Example
const caveats = [{
  type: "limitedCalls",
  limit: 1,
}];
multiTokenPeriod
Ensures that token transfers for multiple tokens stay within the specified limits for the defined periods. At the start of each new period, the allowed transfer amount for each token resets. Any unused transfer allowance from the previous period expires and does not carry over.

When redeeming the delegation, the index of the relevant token configuration must be specified as the args of this caveat (encoded as uint256 hex value).

Caveat enforcer contract: MultiTokenPeriodEnforcer.sol

Parameters
The list of TokenPeriodConfig objects, where each object contains:

Name	Type	Required	Description
token	Address	Yes	The ERC-20 token contract address as a hex string.
periodAmount	bigint	Yes	The maximum amount of tokens that can be transferred per period.
periodDuration	number	Yes	The duration of each period in seconds.
startDate	number	Yes	The timestamp when the first period begins in seconds.
Example
import { zeroAddress } from 'viem';

// Current time as start date. 
// Since startDate is in seconds, we need to convert milliseconds to seconds.
const startDate = Math.floor(Date.now() / 1000);

const tokenPeriodConfigs = [
  {
    token: "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
    // 1 token with 18 decimals.
    periodAmount: 1000000000000000000n,
     // 1 day in seconds.
    periodDuration: 86400,
    startDate
  },
  {
    // For native token use zeroAddress
    token: zeroAddress,
    // 0.01 ETH in wei.
    periodAmount: 10000000000000000n,
    // 1 hour in seconds.
    periodDuration: 3600,
    startDate
  }
]

const caveats = [{
  type: "multiTokenPeriod",
  tokenPeriodConfigs,
}];
nativeBalanceChange
Ensures that the recipient's native token balance has changed within the allowed bounds — either increased by a minimum or decreased by a maximum specified amount.

Caveat enforcer contract: NativeBalanceChangeEnforcer.sol

Parameters
Name	Type	Required	Description
recipient	Address	Yes	The address on which the checks will be applied.
balance	bigint	Yes	The amount by which the balance must be changed.
changeType	BalanceChangeType	Yes	The balance change type for the native token. Specifies whether the balance should have increased or decreased. Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.
Example
const caveats = [{
  type: "nativeBalanceChange",
  recipient: "0x3fF528De37cd95b67845C1c55303e7685c72F319",
  balance: 1000000n,
  changeType: BalanceChangeType.Increase,
}];
nativeTokenPayment
Enforces payment in native token (for example, ETH) for the right to use the delegation. A permissions context allowing payment must be provided as the args when redeeming the delegation.

Caveat enforcer contract: NativeTokenPaymentEnforcer.sol

Parameters
Name	Type	Required	Description
recipient	Address	Yes	The recipient address who receives the payment.
amount	bigint	Yes	The amount that must be paid.
Example
const caveats = [{
  type: "nativeTokenPayment",
  recipient: "0x3fF528De37cd95b67845C1c55303e7685c72F319",
  amount: 1000000n,
}];
nativeTokenPeriodTransfer
Ensures that native token transfers remain within a predefined limit during a specified time window. At the start of each new period, the allowed transfer amount resets. Any unused transfer allowance from the previous period does not carry over and is forfeited.

Caveat enforcer contract: NativeTokenPeriodTransferEnforcer.sol

Parameters
Name	Type	Required	Description
periodAmount	bigint	Yes	The maximum amount of tokens that can be transferred per period.
periodDuration	number	Yes	The duration of each period in seconds.
startDate	number	Yes	The timestamp when the first period begins in seconds.
Example
// Current time as start date. 
// Since startDate is in seconds, we need to convert milliseconds to seconds.
const startDate = Math.floor(Date.now() / 1000);

const caveats = [{
  type: "nativeTokenPeriodTransfer",
  // 1 ETH in wei.
  periodAmount: 1000000000000000000n,
  // 1 day in seconds.
  periodDuration: 86400,
  startDate,
}];
nativeTokenStreaming
Enforces a linear streaming limit for native tokens (for example, ETH). Nothing is available before the specified start timestamp. At the start timestamp, the specified initial amount becomes immediately available. After that, tokens accrue linearly at the specified rate, capped by the specified maximum.

Caveat enforcer contract: NativeTokenStreamingEnforcer.sol

Parameters
Name	Type	Required	Description
initialAmount	bigint	Yes	The initial amount that can be transferred at start time.
maxAmount	bigint	Yes	The maximum total amount that can be unlocked.
amountPerSecond	bigint	Yes	The rate at which tokens accrue per second.
startTime	number	Yes	The start timestamp in seconds.
Example
// Current time as start date. 
// Since startDate is in seconds, we need to convert milliseconds to seconds.
const startDate = Math.floor(Date.now() / 1000);

const caveats = [{
  type: "nativeTokenStreaming",
  // 0.01 ETH in wei.
  initialAmount: 10000000000000000,
  // 0.5 ETH in wei.
  maxAmount: 500000000000000000n
  // 0.00001 ETH in wei.
  amountPerSecond: 10000000000000n,
  startDate,
}];
nativeTokenTransferAmount
Enforces an allowance of native currency (for example, ETH).

Caveat enforcer contract: NativeTokenTransferAmountEnforcer.sol

Parameters
Name	Type	Required	Description
maxAmount	bigint	Yes	The maximum amount of tokens that can be transferred by delegate.
Example
const caveats = [{
  type: "nativeTokenTransferAmount",
  // 0.00001 ETH in wei.
  maxAmount: 10000000000000000n
}];
nonce
Adds a nonce to a delegation, and revokes previous delegations by incrementing the current nonce by calling incrementNonce(address _delegationManager).

Caveat enforcer contract: NonceEnforcer.sol

Parameters
Name	Type	Required	Description
nonce	Hex	Yes	The nonce to allow bulk revocation of delegations.
Example
const caveats = [{
  type: "nonce",
  nonce: "0x1"
}];
ownershipTransfer
Restricts the execution to only allow ownership transfers, specifically the transferOwnership(address _newOwner) function, for a specified contract.

Caveat enforcer contract: OwnershipTransferEnforcer.sol

Parameters
Name	Type	Required	Description
contractAddress	Address	Yes	The target contract address for which ownership transfers are allowed.
Example
const caveats = [{
  type: "ownershipTransfer",
  contractAddress: "0xc11F3a8E5C7D16b75c9E2F60d26f5321C6Af5E92"
}];
redeemer
Limits the addresses that can redeem the delegation. This caveat is designed to restrict smart contracts or EOAs lacking delegation support, and can be placed anywhere in the delegation chain to restrict the redeemer.

note
Delegator accounts with delegation functionalities can bypass these restrictions by delegating to other addresses. For example, Alice makes Bob the redeemer. This condition is enforced, but if Bob is a delegator he can create a separate delegation to Carol that allows her to redeem Alice's delegation through Bob.

Caveat enforcer contract: RedeemerEnforcer.sol

Parameters
Name	Type	Required	Description
redeemers	Address[]	Yes	The list of addresses that are allowed to redeem the delegation.
Example
const caveats = [{
  type: "redeemer",
  redeemers: [
    "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
    "0x6be97c23596ECed7170fdFb28e8dA1Ca5cdc54C5"
  ],
}];
specificActionERC20TransferBatch
Ensures validation of a batch consisting of exactly two transactions:

The first transaction must call a specific target contract with predefined calldata.
The second transaction must be an ERC-20 token transfer that matches specified parameters—including the ERC-20 token contract address, amount, and recipient.
Caveat enforcer contract: SpecificActionERC20TransferBatchEnforcer.sol

Parameters
Name	Type	Required	Description
tokenAddress	Address	Yes	The ERC-20 token contract address.
recipient	Address	Yes	The address that will receive the tokens.
amount	bigint	Yes	The amount of tokens to transfer.
target	Address	Yes	The target address for the first transaction.
calldata	Hex	Yes	The calldata for the first transaction.
Example
const caveats = [{
  type: "specificActionERC20TransferBatch",
  tokenAddress: "0xb4aE654Aca577781Ca1c5DE8FbE60c2F423f37da",
  recipient: "0x027aeAFF3E5C33c4018FDD302c20a1B83aDCD96C",
  // 1 ERC-20 token - 18 decimals, in wei
  amount: 1000000000000000000n,
  target: "0xb49830091403f1Aa990859832767B39c25a8006B",
  calldata: "0x1234567890abcdef"
}];
timestamp
Specifies a range of timestamps through which the delegation will be valid.

Caveat enforcer contract: TimestampEnforcer.sol

Parameters
Name	Type	Required	Description
afterThreshold	number	Yes	The timestamp after which the delegation is valid in seconds. Set the value to 0 to disable this threshold.
beforeThreshold	number	Yes	The timestamp before which the delegation is valid in seconds. Set the value to 0 to disable this threshold.
Example
// We need to convert milliseconds to seconds.
const currentTime = Math.floor(Date.now() / 1000);
// 1 hour after current time.
const afterThreshold = currentTime + 3600;
// 1 day after afterThreshold
const beforeThreshold = afterThreshold + 86400;

const caveats = [{
  type: "timestamp",
  afterThreshold,
  beforeThreshold,
}];
valueLte
Limits the value of native tokens that the delegate can spend.

Caveat enforcer contract: ValueLteEnforcer.sol

Parameters
Name	Type	Required	Description
maxValue	bigint	Yes	The maximum value that may be specified when redeeming this delegation.
Example
const caveats = [{
  type: "valueLte",
  // 0.01 ETH in wei.
  maxValue: 10000000000000000n
}];
Caveat Enforcer Client
The following API methods are related to CaveatEnforcerClient used to check the delegation state.

createCaveatEnforcerClient
Create a Viem Client extended with caveat enforcer actions. This client allows you to interact with the caveat enforcers of the delegation, and read the required state.

Parameters
Name	Type	Required	Description
client	Client	Yes	The Viem Client to interact with the caveat enforcer contracts and read their state.
environment	DeleGatorEnvironment	Yes	Environment to resolve the smart contracts for the current chain.
Example
example.ts
config.ts
import { environment, publicClient as client } from './config.ts'
import { createCaveatEnforcerClient } from '@metamask/delegation-toolkit'

const caveatEnforcerClient = createCaveatEnforcerClient({
  environment,
  client,
})
getErc20PeriodTransferEnforcerAvailableAmount
Returns the available amount from the ERC-20 period transfer enforcer for the current period.

Parameters
Name	Type	Required	Description
delegation	Delegation	Yes	The delegation object for which you want to check the available amount.
Example
example.ts
config.ts
import { delegation } './config.ts'

// Returns the available amount for current period. 
const { availableAmount } = await caveatEnforcerClient.getErc20PeriodTransferEnforcerAvailableAmount({
  delegation,
})
getErc20StreamingEnforcerAvailableAmount
Returns the available amount from the ERC-20 streaming enforcer.

Parameters
Name	Type	Required	Description
delegation	Delegation	Yes	The delegation object for which you want to check the available amount.
Example
example.ts
config.ts
import { delegation } './config.ts'

// Returns the available amount 
const { availableAmount } = await caveatEnforcerClient.getErc20StreamingEnforcerAvailableAmount({
  delegation,
})
getNativeTokenPeriodTransferEnforcerAvailableAmount
Returns the available amount from the native token period enforcer for the current period.

Parameters
Name	Type	Required	Description
delegation	Delegation	Yes	The delegation object for which you want to check the available amount.
Example
example.ts
config.ts
import { delegation } './config.ts'

// Returns the available amount for current period. 
const { availableAmount } = await caveatEnforcerClient.getNativeTokenPeriodTransferEnforcerAvailableAmount({
  delegation,
})
getNativeTokenStreamingEnforcerAvailableAmount
Returns the available amount from the native streaming enforcer.

Parameters
Name	Type	Required	Description
delegation	Delegation	Yes	The delegation object for which you want to check the available amount.
Example
example.ts
config.ts
import { delegation } './config.ts'

// Returns the available amount 
const { availableAmount } = await caveatEnforcerClient.getNativeTokenStreamingEnforcerAvailableAmount({
  delegation,
})
getMultiTokenPeriodEnforcerAvailableAmount
Returns the available amount from the multi token period transfer enforcer for the current period. You'll need to encode the args for the token index you want to check the available amount.

Parameters
Name	Type	Required	Description
delegation	Delegation	Yes	The delegation object with token index for which you want to check the available amount.
Example
example.ts
config.ts
import { delegation } './config.ts'

// Encode the args for the multiTokenPeriod enforcer.
const args = encodePacked(['uint256'], [BigInt(0)]);

// Ensure the index is correct when working with multiple enforcers.
delegation.caveats[0].args = args

// Returns the available amount for the first token in the list.  
const { availableAmount } = await caveatEnforcerClient.getMultiTokenPeriodEnforcerAvailableAmount({
  delegation,
})

Yêu cầu của dự án là: 
Description (Mô tả)

Xem livestream khởi động hackathon

Hackathon MetaMask Smart Accounts x Monad x Envio mời gọi các nhà phát triển, nhà thiết kế và nhà đổi mới xây dựng các trải nghiệm Web3 thế hệ tiếp theo trên Monad tập trung vào trừu tượng tài khoản (account abstraction) và trải nghiệm người dùng.

Về MetaMask Smart Accounts

Được cung cấp bởi ERC-4337 và ERC-7710, MetaMask Smart Accounts mang lại tính mô-đun và linh hoạt cho ví, kích hoạt các tính năng như giao dịch không tốn gas (gasless transactions), hỗ trợ khóa bảo mật (passkey), và chia sẻ quyền nâng cao cho các tương tác bảo mật và liền mạch.

Với MetaMask Smart Accounts, các nhà phát triển có thể tạo ra những chiếc ví vượt ra ngoài khả năng kiểm soát đơn giản dựa trên khóa, tích hợp logic có thể lập trình để thu hút người dùng, bảo mật và cải thiện trải nghiệm người dùng.

Về Monad

Monad là một L1 tương thích Ethereum có hiệu suất cao. Monad thúc đẩy đáng kể ranh giới hiệu quả trong sự cân bằng giữa phi tập trung và khả năng mở rộng, kết quả là Monad đã đạt được thông lượng 10,000 giao dịch mỗi giây (tps), tần suất khối 400ms và thời gian xác nhận cuối cùng (finality) 800ms.

Về Envio

Envio là một bộ lập chỉ mục blockchain (indexer) hiệu suất cao được thiết kế để theo dõi sự kiện và thay đổi trạng thái trên nhiều mạng lưới với tốc độ và hiệu quả. Được xây dựng trên công cụ HyperSync, nó cho phép các nhà phát triển dễ dàng truy vấn dữ liệu blockchain thông qua GraphQL, cung cấp các API sẵn sàng cho môi trường sản xuất và theo thời gian thực.

Yêu Cầu Đủ Điều Kiện

Dự án phải sử dụng MetaMask Smart Accounts. MetaMask Smart Accounts độc lập với trình ký (signer agnostic), vì vậy bạn có thể sử dụng bất kỳ nhà cung cấp ví nào bạn chọn, ví dụ: tiện ích mở rộng MetaMask, MetaMask Embedded Wallets, Dynamic hoặc Privy.

Dự án phải được triển khai trên mạng thử nghiệm Monad (Monad testnet). Nếu chọn theo hướng đa chuỗi (cross chain track), thì đó phải là mạng thử nghiệm Monad + bất kỳ chuỗi nào khác.

Để tích hợp MetaMask Smart Accounts, hãy sử dụng Delegation Toolkit SDK.

Video demo dự án phải thể hiện một tích hợp MetaMask Smart Accounts đang hoạt động trên Monad trong luồng hoạt động chính của ứng dụng.

Ban giám khảo có quyền quyết định không trao giải cho một hạng mục nếu không có dự án nào đáp ứng các tiêu chuẩn nội bộ của họ, ngoài các tiêu chí nộp bài cơ bản.

Yêu Cầu Thưởng Bổ Sung từ Envio
Để đủ điều kiện nhận thưởng từ Envio, các dự án phải chứng minh được việc sử dụng cơ sở hạ tầng của Envio (ví dụ: HyperIndex hoặc HyperSync) như một phần cốt lõi trong bài nộp. Điều này có thể là cung cấp năng lượng cho một bộ lập chỉ mục, kích hoạt thông báo, xây dựng đường truyền dữ liệu, hoặc bất kỳ tích hợp sáng tạo nào khác. Bằng chứng sử dụng Envio đầy đủ bao gồm, nhưng không giới hạn ở:

Một bộ lập chỉ mục (indexer) hoạt động sử dụng Envio.

Truy vấn và sử dụng API của HyperSync.

Các truy vấn hoặc điểm cuối (endpoints) được tạo bởi Envio được sử dụng trong dự án.

Tài liệu, mã nguồn hoặc bản demo cho thấy Envio đang hỗ trợ tích cực cho chức năng của dự án.
